GAS LISTING /tmp/ccNZ67a0.s 			page 1


   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/bernhard/source/avr-edid-spoofer/",100,0,2,.Ltext0
   8               		.stabs	"main.c",100,0,2,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  13               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,0,0
  14               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  15               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  16               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  17               		.stabs	"__int128:t(0,6)=@s128;r(0,6);02000000000000000000000000000000000000000000;0177777777777777
  18               		.stabs	"__int128 unsigned:t(0,7)=@s128;r(0,7);0;03777777777777777777777777777777777777777777;",128
  19               		.stabs	"long long int:t(0,8)=@s64;r(0,8);01000000000000000000000;00777777777777777777777;",128,0,0
  20               		.stabs	"long long unsigned int:t(0,9)=@s64;r(0,9);0;01777777777777777777777;",128,0,0,0
  21               		.stabs	"short int:t(0,10)=r(0,10);-32768;32767;",128,0,0,0
  22               		.stabs	"short unsigned int:t(0,11)=r(0,11);0;0177777;",128,0,0,0
  23               		.stabs	"signed char:t(0,12)=@s8;r(0,12);-128;127;",128,0,0,0
  24               		.stabs	"unsigned char:t(0,13)=@s8;r(0,13);0;255;",128,0,0,0
  25               		.stabs	"float:t(0,14)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"double:t(0,15)=r(0,1);4;0;",128,0,0,0
  27               		.stabs	"long double:t(0,16)=r(0,1);4;0;",128,0,0,0
  28               		.stabs	"short _Fract:t(0,17)=r(0,1);1;0;",128,0,0,0
  29               		.stabs	"_Fract:t(0,18)=r(0,1);2;0;",128,0,0,0
  30               		.stabs	"long _Fract:t(0,19)=r(0,1);4;0;",128,0,0,0
  31               		.stabs	"long long _Fract:t(0,20)=r(0,1);8;0;",128,0,0,0
  32               		.stabs	"unsigned short _Fract:t(0,21)=r(0,1);1;0;",128,0,0,0
  33               		.stabs	"unsigned _Fract:t(0,22)=r(0,1);2;0;",128,0,0,0
  34               		.stabs	"unsigned long _Fract:t(0,23)=r(0,1);4;0;",128,0,0,0
  35               		.stabs	"unsigned long long _Fract:t(0,24)=r(0,1);8;0;",128,0,0,0
  36               		.stabs	"_Sat short _Fract:t(0,25)=r(0,1);1;0;",128,0,0,0
  37               		.stabs	"_Sat _Fract:t(0,26)=r(0,1);2;0;",128,0,0,0
  38               		.stabs	"_Sat long _Fract:t(0,27)=r(0,1);4;0;",128,0,0,0
  39               		.stabs	"_Sat long long _Fract:t(0,28)=r(0,1);8;0;",128,0,0,0
  40               		.stabs	"_Sat unsigned short _Fract:t(0,29)=r(0,1);1;0;",128,0,0,0
  41               		.stabs	"_Sat unsigned _Fract:t(0,30)=r(0,1);2;0;",128,0,0,0
  42               		.stabs	"_Sat unsigned long _Fract:t(0,31)=r(0,1);4;0;",128,0,0,0
  43               		.stabs	"_Sat unsigned long long _Fract:t(0,32)=r(0,1);8;0;",128,0,0,0
  44               		.stabs	"short _Accum:t(0,33)=r(0,1);2;0;",128,0,0,0
  45               		.stabs	"_Accum:t(0,34)=r(0,1);4;0;",128,0,0,0
  46               		.stabs	"long _Accum:t(0,35)=r(0,1);8;0;",128,0,0,0
  47               		.stabs	"long long _Accum:t(0,36)=r(0,1);8;0;",128,0,0,0
  48               		.stabs	"unsigned short _Accum:t(0,37)=r(0,1);2;0;",128,0,0,0
  49               		.stabs	"unsigned _Accum:t(0,38)=r(0,1);4;0;",128,0,0,0
  50               		.stabs	"unsigned long _Accum:t(0,39)=r(0,1);8;0;",128,0,0,0
  51               		.stabs	"unsigned long long _Accum:t(0,40)=r(0,1);8;0;",128,0,0,0
  52               		.stabs	"_Sat short _Accum:t(0,41)=r(0,1);2;0;",128,0,0,0
  53               		.stabs	"_Sat _Accum:t(0,42)=r(0,1);4;0;",128,0,0,0
  54               		.stabs	"_Sat long _Accum:t(0,43)=r(0,1);8;0;",128,0,0,0
  55               		.stabs	"_Sat long long _Accum:t(0,44)=r(0,1);8;0;",128,0,0,0
  56               		.stabs	"_Sat unsigned short _Accum:t(0,45)=r(0,1);2;0;",128,0,0,0
  57               		.stabs	"_Sat unsigned _Accum:t(0,46)=r(0,1);4;0;",128,0,0,0
GAS LISTING /tmp/ccNZ67a0.s 			page 2


  58               		.stabs	"_Sat unsigned long _Accum:t(0,47)=r(0,1);8;0;",128,0,0,0
  59               		.stabs	"_Sat unsigned long long _Accum:t(0,48)=r(0,1);8;0;",128,0,0,0
  60               		.stabs	"void:t(0,49)=(0,49)",128,0,0,0
  61               		.stabs	"projInfo.h",130,0,0,0
  62               		.stabs	"/usr/lib/avr/include/inttypes.h",130,0,0,0
  63               		.stabs	"/usr/lib/gcc/avr/5.4.0/include/stdint.h",130,0,0,0
  64               		.stabs	"/usr/lib/avr/include/stdint.h",130,0,0,0
  65               		.stabs	"int8_t:t(4,1)=(0,12)",128,0,125,0
  66               		.stabs	"uint8_t:t(4,2)=(0,13)",128,0,126,0
  67               		.stabs	"int16_t:t(4,3)=(0,1)",128,0,127,0
  68               		.stabs	"uint16_t:t(4,4)=(0,4)",128,0,128,0
  69               		.stabs	"int32_t:t(4,5)=(0,3)",128,0,129,0
  70               		.stabs	"uint32_t:t(4,6)=(0,5)",128,0,130,0
  71               		.stabs	"int64_t:t(4,7)=(0,8)",128,0,132,0
  72               		.stabs	"uint64_t:t(4,8)=(0,9)",128,0,133,0
  73               		.stabs	"intptr_t:t(4,9)=(4,3)",128,0,146,0
  74               		.stabs	"uintptr_t:t(4,10)=(4,4)",128,0,151,0
  75               		.stabs	"int_least8_t:t(4,11)=(4,1)",128,0,163,0
  76               		.stabs	"uint_least8_t:t(4,12)=(4,2)",128,0,168,0
  77               		.stabs	"int_least16_t:t(4,13)=(4,3)",128,0,173,0
  78               		.stabs	"uint_least16_t:t(4,14)=(4,4)",128,0,178,0
  79               		.stabs	"int_least32_t:t(4,15)=(4,5)",128,0,183,0
  80               		.stabs	"uint_least32_t:t(4,16)=(4,6)",128,0,188,0
  81               		.stabs	"int_least64_t:t(4,17)=(4,7)",128,0,196,0
  82               		.stabs	"uint_least64_t:t(4,18)=(4,8)",128,0,203,0
  83               		.stabs	"int_fast8_t:t(4,19)=(4,1)",128,0,217,0
  84               		.stabs	"uint_fast8_t:t(4,20)=(4,2)",128,0,222,0
  85               		.stabs	"int_fast16_t:t(4,21)=(4,3)",128,0,227,0
  86               		.stabs	"uint_fast16_t:t(4,22)=(4,4)",128,0,232,0
  87               		.stabs	"int_fast32_t:t(4,23)=(4,5)",128,0,237,0
  88               		.stabs	"uint_fast32_t:t(4,24)=(4,6)",128,0,242,0
  89               		.stabs	"int_fast64_t:t(4,25)=(4,7)",128,0,250,0
  90               		.stabs	"uint_fast64_t:t(4,26)=(4,8)",128,0,257,0
  91               		.stabs	"intmax_t:t(4,27)=(4,7)",128,0,277,0
  92               		.stabs	"uintmax_t:t(4,28)=(4,8)",128,0,282,0
  93               		.stabn	162,0,0,0
  94               		.stabn	162,0,0,0
  95               		.stabs	"int_farptr_t:t(2,1)=(4,5)",128,0,77,0
  96               		.stabs	"uint_farptr_t:t(2,2)=(4,6)",128,0,81,0
  97               		.stabn	162,0,0,0
  98               		.stabn	162,0,0,0
  99               		.stabs	"main.h",130,0,0,0
 100               		.stabs	"/usr/lib/avr/include/avr/io.h",130,0,0,0
 101               		.stabs	"/usr/lib/avr/include/avr/fuse.h",130,0,0,0
 102               		.stabs	"__fuse_t:t(7,1)=(7,2)=s3low:(0,13),0,8;high:(0,13),8,8;extended:(0,13),16,8;;",128,0,244,0
 103               		.stabn	162,0,0,0
 104               		.stabn	162,0,0,0
 105               		.stabs	"_commonCode_localized/heartbeat/1.21/heartbeat.h",130,0,0,0
 106               		.stabs	"./_commonCode_localized/hfModulation/1.00/hfModulation.h",130,0,0,0
 107               		.stabs	"hfm_t:t(9,1)=(9,2)=B(9,3)=s4desiredSum:(4,3),0,16;maxPower:(4,2),16,8;power:(4,2),24,8;;",
 108               		.stabn	162,0,0,0
 109               		.stabs	"./_commonCode_localized/dmsTimer/1.13/dmsTimer.h",130,0,0,0
 110               		.stabs	"dms6sec_t:t(10,1)=(4,4)",128,0,81,0
 111               		.stabs	"dms4day_t:t(10,2)=(4,6)",128,0,83,0
 112               		.stabs	"dmsMax_t:t(10,3)=(4,6)",128,0,84,0
 113               		.stabn	162,0,0,0
 114               		.stabn	162,0,0,0
GAS LISTING /tmp/ccNZ67a0.s 			page 3


 115               		.stabn	162,0,0,0
 116               		.stabs	"_commonCode_localized/sineTable/0.99/sineTable.h",130,0,0,0
 117               		.stabs	"/usr/lib/avr/include/avr/pgmspace.h",130,0,0,0
 118               		.stabs	"/usr/lib/gcc/avr/5.4.0/include/stddef.h",130,0,0,0
 119               		.stabs	"size_t:t(13,1)=(0,4)",128,0,216,0
 120               		.stabn	162,0,0,0
 121               		.stabn	162,0,0,0
 122               		.stabs	"theta_t:t(11,1)=(4,3)",128,0,76,0
 123               		.stabs	"axis_t:t(11,2)=(4,5)",128,0,123,0
 124               		.stabn	162,0,0,0
 125               		.stabs	"usi_i2c_awaitStart:F(0,49)",36,0,835,usi_i2c_awaitStart
 126               	.global	usi_i2c_awaitStart
 127               		.type	usi_i2c_awaitStart, @function
 128               	usi_i2c_awaitStart:
 129               		.stabd	46,0,0
   1:main.c        **** #include "projInfo.h"	//Don't include in main.h 'cause that's included in other .c's?
   2:main.c        **** #include "main.h"
   3:main.c        **** 
   4:main.c        **** 
   5:main.c        **** //Need to save memory space for the Tiny45...
   6:main.c        **** // (Actually, now it fits.
   7:main.c        **** //  FADER just uses the three remaining pins to cyclicly fade three LEDs
   8:main.c        **** //  You can just ignore/disable it.)
   9:main.c        **** #define FADER_ENABLED TRUE //FALSE
  10:main.c        **** 
  11:main.c        **** #if (defined(FADER_ENABLED) && FADER_ENABLED)
  12:main.c        **** #include _SINETABLE_HEADER_
  13:main.c        **** #endif
  14:main.c        **** 
  15:main.c        **** 
  16:main.c        **** //For hacking when connected in single-pix mode
  17:main.c        **** // (e.g. every-other pixel will either be black or white)
  18:main.c        **** // Just comment-them-out when the single-to-dual converter is ready...
  19:main.c        **** //#define H_RES	700L
  20:main.c        **** // Unused:
  21:main.c        **** //#define V_RES	1050
  22:main.c        **** 
  23:main.c        **** //A/O v48:
  24:main.c        **** // I tend to use SwitchResX to test values, so set those values here.
  25:main.c        **** // These are the values output by the GPU (single-pixel)
  26:main.c        **** // They'll be converted to dual-pixel values as appropriate...
  27:main.c        **** // (And apparently some of the math divides it in half then later
  28:main.c        **** //  multiplies it by 2... so best not to have odd values here)
  29:main.c        **** // #define PIX_CLK_GPU	(100000000UL)
  30:main.c        **** #define PIX_CLK_GPU	(84000000UL)
  31:main.c        **** 
  32:main.c        **** /*
  33:main.c        **** Bbsod1: laut wiki ist die richtige modeline für den beamer: "1280x800@60" 83.91 1280 1312 1624 165
  34:main.c        **** d.h.:  pixelclock: 89.91 Hz, auflösung: 1280x800,  h_sync: 1312, h_sync_end: 1624 h_blank_end: 165
  35:main.c        **** width: 1280
  36:main.c        **** frontPorch: 1312 (32)
  37:main.c        **** syncPulse: 1624  (312)
  38:main.c        **** backPorch: 1656  (32)
  39:main.c        **** 
  40:main.c        **** height: 800
  41:main.c        **** frontPorch 816 (16)
  42:main.c        **** syncPulse: 824 (8)
GAS LISTING /tmp/ccNZ67a0.s 			page 4


  43:main.c        **** backPorch: 841 (17)
  44:main.c        **** 
  45:main.c        **** */
  46:main.c        **** 
  47:main.c        **** #define H_ACTIVE_GPU	(1280)		//Active pixels
  48:main.c        **** // #define H_FP_GPU		(32)			//Front Porch
  49:main.c        **** // #define H_WIDTH_GPU	(312)			//Sync Width
  50:main.c        **** // #define H_BP_GPU		(32)			//Back Porch
  51:main.c        **** #define H_FP_GPU		(32)			//Front Porch
  52:main.c        **** #define H_WIDTH_GPU	(64)			//Sync Width
  53:main.c        **** #define H_BP_GPU		(32)			//Back Porch
  54:main.c        **** //a/o v48:
  55:main.c        **** //Oddly, 16,16,64 worked with SwitchResX, but *here* they caused a
  56:main.c        **** // horizontal shift... 120 seems to have fixed it.
  57:main.c        **** // It could be that the display was already properly-synced from a
  58:main.c        **** // different timing, then switching to the new timing allowed it to remain
  59:main.c        **** // synced. Or maybe I've got some integer-rounding in here...? I dunno.
  60:main.c        **** //a/o v51:
  61:main.c        **** // 16,16,120 seems to work, but every once in a while I see a glitch in
  62:main.c        **** // terminal (sharp contrast, I guess)
  63:main.c        **** 
  64:main.c        **** #define V_ACTIVE_GPU	(800)		//Active Rows
  65:main.c        **** // #define V_FP_GPU		(16)			//Front Porch
  66:main.c        **** // #define V_WIDTH_GPU	(8)			//Sync Rows
  67:main.c        **** // #define V_BP_GPU		(17)			//Back Porch
  68:main.c        **** #define V_FP_GPU		(15)			//Front Porch
  69:main.c        **** #define V_WIDTH_GPU	(8)			//Sync Rows
  70:main.c        **** #define V_BP_GPU		(16)			//Back Porch
  71:main.c        **** 
  72:main.c        **** 
  73:main.c        **** 
  74:main.c        **** //If you want to have alternate-timings available, set this TRUE and enter
  75:main.c        **** //the alternate-values below.
  76:main.c        **** #define ALT_TIMING	FALSE
  77:main.c        **** 
  78:main.c        **** 
  79:main.c        **** 
  80:main.c        **** #if (defined(ALT_TIMING) && ALT_TIMING)
  81:main.c        **** // According to spwg, there's room for at least one "alternate timing"
  82:main.c        **** // This could be useful here, for saving a couple values to try-out...
  83:main.c        **** // e.g. 57Hz refresh worked perfectly, as far as I could tell, but I wanted
  84:main.c        **** // to see if I could bump that up... 60Hz looked great, until I was working
  85:main.c        **** // in Terminal (lots of contrast), and I noticed a few lines would skip...
  86:main.c        **** // Hopefully, if this works, having an alternate-timing of the
  87:main.c        **** // previously-working values will make switching back easy...
  88:main.c        **** // Haven't yet figured out how I'm going to implement this...
  89:main.c        **** // Alternate-timing kinda makes sense as the reliable fall-back
  90:main.c        **** // OTOH, if the main timing is set to something non-bootable, then what?
  91:main.c        **** // (If the experimental timing is put here in ALT_TIMING, then it could be
  92:main.c        **** // tested *after* booting with reliable values... OTOH, I've *also* found
  93:main.c        **** // that (maybe) the display itself has a better time syncing if it'd
  94:main.c        **** // already synced since power-up... so switching to a new (questionable)
  95:main.c        **** // value may work after the system has booted, but may not work upon a
  96:main.c        **** // fresh boot... 
  97:main.c        **** 
  98:main.c        **** // Anyways, these are the same macro-names as above, just with _ALT.
  99:main.c        **** 
GAS LISTING /tmp/ccNZ67a0.s 			page 5


 100:main.c        **** #define PIX_CLK_GPU_ALT	(100000000UL)
 101:main.c        **** 
 102:main.c        **** //These values are for a 57Hz refresh
 103:main.c        **** #define H_ACTIVE_GPU_ALT	(1400)		//Active pixels
 104:main.c        **** #define H_FP_GPU_ALT			(32)			//Front Porch
 105:main.c        **** #define H_WIDTH_GPU_ALT		(32)			//Sync Width
 106:main.c        **** #define H_BP_GPU_ALT			(180)			//Back Porch
 107:main.c        **** 
 108:main.c        **** #define V_ACTIVE_GPU_ALT	(1050)		//Active Rows
 109:main.c        **** #define V_FP_GPU_ALT			(2)			//Front Porch
 110:main.c        **** #define V_WIDTH_GPU_ALT		(2)			//Sync Rows
 111:main.c        **** #define V_BP_GPU_ALT 		(6)			//Back Porch
 112:main.c        **** 
 113:main.c        **** //a/o v51:
 114:main.c        **** //These are values used in the actual EDID array...
 115:main.c        **** // This avoids all single-to-dual translation, etc. that makes 
 116:main.c        **** // it complicated to figure out where the NON-ALT values come from...
 117:main.c        **** // (that stuff is, again, remnants of an older time, not relevent to most
 118:main.c        **** // purposes)
 119:main.c        **** #define H_BLANKING_ALT (H_FP_GPU_ALT + H_WIDTH_GPU_ALT + H_BP_GPU_ALT)
 120:main.c        **** #define V_BLANKING_ALT (V_FP_GPU_ALT + V_WIDTH_GPU_ALT + V_BP_GPU_ALT)
 121:main.c        **** 
 122:main.c        **** #endif
 123:main.c        **** 
 124:main.c        **** 
 125:main.c        **** //Currently, neither of these values can be greater than 255
 126:main.c        **** // it should be a simple change.
 127:main.c        **** #define H_IMAGE_SIZE_MM_LTD   245L
 128:main.c        **** #define V_IMAGE_SIZE_MM_LTD	184L
 129:main.c        **** 
 130:main.c        **** 
 131:main.c        **** 
 132:main.c        **** 
 133:main.c        **** 
 134:main.c        **** 
 135:main.c        **** //These are dual-pixel frequencies...
 136:main.c        **** // e.g. the single-pixel transmitter (built into the mac)
 137:main.c        **** // runs at twice this speed...
 138:main.c        **** //15MHz looks nasty on boot, but macOS handles it fine
 139:main.c        **** //20MHz Boots fine
 140:main.c        **** //85MHz (single) looks great, only slight flicker (42.5MHz dual) = 47Hz
 141:main.c        **** //SwitchResX Test at 53Hz = color inversion like the plasma...
 142:main.c        **** // bit-shifts due to unmatched cable lengths?
 143:main.c        **** // bounce due to termination placement?
 144:main.c        **** //#define PIX_CLK_OVERRIDE (42500000L)
 145:main.c        **** // As Of v47: 100MHz works, 104 causes jitter... (tested in SwitchResX)
 146:main.c        **** 
 147:main.c        **** 
 148:main.c        **** //a/o v51: There've been some unusual testing in here...
 149:main.c        **** //         e.g. one of the first experiments was to use a dual-pixel
 150:main.c        **** //         display *directly* with the single-pixel GPU. Thus, the
 151:main.c        **** //         horizontal resolution, according to the computer, was 1/2 the 
 152:main.c        **** //			  physical resolution of the screen...
 153:main.c        **** //         Later, this display was connected via a single-to-dual pixel
 154:main.c        **** //         converter. At this point, the EDID information shouldn't rely in
 155:main.c        **** //         any way on the fact that the display is a dual-pixel display
 156:main.c        **** //         since it looks like a single-pixel display to the computer.
GAS LISTING /tmp/ccNZ67a0.s 			page 6


 157:main.c        **** //         But the weird math remains here.
 158:main.c        **** //         As a result of these strange tests, there's some weird stuff in
 159:main.c        **** //         here regarding H_RES and PIX_CLK_OVERRIDE, etc.
 160:main.c        **** //         I haven't yet removed it.
 161:main.c        **** // e.g. As it's currently configured...
 162:main.c        **** //      (note that _LTD is referring to my LTD121... LCD. NOT "limited")
 163:main.c        **** //      PIX_CLK = PIX_CLK_TYP_LTD*2
 164:main.c        **** //                PIX_CLK_TYP_LTD = PIX_CLK_OVERRIDE
 165:main.c        **** //                                  PIX_CLK_OVERRIDE = PIX_CLK_GPU/2
 166:main.c        **** // Thus: PIX_CLK = PIX_CLK_GPU (minus rounding error)
 167:main.c        **** //
 168:main.c        **** //      H_ACTIVE = H_PIXEL_CLOCKS_LTD*2
 169:main.c        **** //                 H_PIXEL_CLOCKS_LTD = H_ACTIVE_GPU/2
 170:main.c        **** // Thus H_ACTIVE = H_ACTIVE_GPU
 171:main.c        **** //
 172:main.c        **** // H_BLANKING = H_BLANKING_TYP_LTD*2
 173:main.c        **** //              H_BLANKING_TYP_LTD = (H_FP_GPU+H_WIDTH_GPU+H_BP_GPU)/2 
 174:main.c        **** // H_BLANKING = H_FP_GPU + H_WIDTH_GPU + H_BP_GPU
 175:main.c        **** //
 176:main.c        **** // V_ACTIVE = V_ACTIVE_GPU
 177:main.c        **** //
 178:main.c        **** // V_BLANKING = V_BLANKING_TYP
 179:main.c        **** //					 V_BLANKING_TYP = V_FP_GPU + V_WIDTH_GPU + V_BP_GPU
 180:main.c        **** //
 181:main.c        **** // THFP = THFP_LTD*2
 182:main.c        **** //        THFP_LTD = H_FP_GPU/2
 183:main.c        **** // THFP = H_FP_GPU
 184:main.c        **** //
 185:main.c        **** // THW = THW_LTD*2
 186:main.c        **** //       THW_LTD = H_WIDTH_GPU/2
 187:main.c        **** // THW = H_WIDTH_GPU
 188:main.c        **** //
 189:main.c        **** // TVFP = V_FP_GPU
 190:main.c        **** // TVW = V_WIDTH_GPU 
 191:main.c        **** 
 192:main.c        **** 
 193:main.c        **** #define PIX_CLK_OVERRIDE (PIX_CLK_GPU/2) //(50000000L)
 194:main.c        **** 
 195:main.c        **** 
 196:main.c        **** //WTF: 4196 Bytes in Text region, not complaining?!
 197:main.c        **** //  Apparently somewhere in avr-gcc/libc...?
 198:main.c        **** //  (avrdude gives error when trying to write...)
 199:main.c        **** //int test[400] = {1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8};
 200:main.c        **** /*int test(void)
 201:main.c        **** {
 202:main.c        **** 	int i;
 203:main.c        **** 	int j,k;
 204:main.c        **** 
 205:main.c        **** 	j=0;
 206:main.c        **** 
 207:main.c        **** 	for(i=0; i<85; i++)
 208:main.c        **** 	{
 209:main.c        **** 		setbit(i%8, j);
 210:main.c        **** 		for(k=0; k<254; k++)
 211:main.c        **** 			setbit((k+i)%7, j);
 212:main.c        **** 	}
 213:main.c        **** 
GAS LISTING /tmp/ccNZ67a0.s 			page 7


 214:main.c        **** 	return j;
 215:main.c        **** 
 216:main.c        **** }
 217:main.c        **** */
 218:main.c        **** 
 219:main.c        **** 
 220:main.c        **** //This is the display's pixel-clock...
 221:main.c        **** #ifndef PIX_CLK_OVERRIDE
 222:main.c        **** #error "This error is just a message to me, in case my variables aren't set as I'd expected"
 223:main.c        **** #define PIX_CLK_TYP_LTD (54000000L)
 224:main.c        **** #else
 225:main.c        **** #define PIX_CLK_TYP_LTD PIX_CLK_OVERRIDE
 226:main.c        **** #endif
 227:main.c        **** 
 228:main.c        **** //This is the display's number of active pixel-clocks
 229:main.c        **** #define H_PIXEL_CLOCKS_LTD   (H_ACTIVE_GPU/2)	//700
 230:main.c        **** // and inactive...
 231:main.c        **** #define H_BLANKING_TYP_LTD 	((H_FP_GPU+H_WIDTH_GPU+H_BP_GPU)/2)	//144
 232:main.c        **** 
 233:main.c        **** //Horiz Sync Offset (THFP)
 234:main.c        **** //#define THFP_MIN_LTD (H_FP_GPU/2)	//8
 235:main.c        **** #define THFP_LTD (H_FP_GPU/2) //(THFP_MIN_LTD*2)
 236:main.c        **** 
 237:main.c        **** //Horiz Sync Pulse-Width
 238:main.c        **** //#define THW_MIN_LTD 	(H_WIDTH_GPU/2) // 8
 239:main.c        **** #define THW_LTD  (H_WIDTH_GPU/2)//(THW_MIN_LTD*2)
 240:main.c        **** 
 241:main.c        **** #ifdef H_RES
 242:main.c        **** #error "This error is just a message to me, in case I have H_RES still defined"
 243:main.c        **** // #define H_IMAGE_SIZE_MM ((uint8_t)((H_IMAGE_SIZE_MM_LTD*H_RES)/1400L))
 244:main.c        ****  #define H_IMAGE_SIZE_MM \
 245:main.c        **** 	((uint8_t)((H_IMAGE_SIZE_MM_LTD*H_RES)/(H_ACTIVE_GPU)))
 246:main.c        ****  #define V_IMAGE_SIZE_MM	V_IMAGE_SIZE_MM_LTD
 247:main.c        **** 
 248:main.c        ****  #define PIX_CLK  (PIX_CLK_TYP_LTD)
 249:main.c        ****  #define H_ACTIVE    (H_PIXEL_CLOCKS_LTD)
 250:main.c        ****  #define H_BLANKING  (H_BLANKING_TYP_LTD)
 251:main.c        ****  #define THFP (THFP_LTD)
 252:main.c        ****  #define THW (THW_LTD)
 253:main.c        **** #else
 254:main.c        ****  #define H_IMAGE_SIZE_MM	H_IMAGE_SIZE_MM_LTD
 255:main.c        ****  #define V_IMAGE_SIZE_MM	V_IMAGE_SIZE_MM_LTD
 256:main.c        **** 
 257:main.c        ****  #define PIX_CLK  (PIX_CLK_TYP_LTD*2)
 258:main.c        ****  #define H_ACTIVE (H_PIXEL_CLOCKS_LTD*2)
 259:main.c        ****  #define H_BLANKING  (H_BLANKING_TYP_LTD*2)
 260:main.c        ****  #define THFP (THFP_LTD*2)
 261:main.c        ****  #define THW (THW_LTD*2)
 262:main.c        **** #endif
 263:main.c        **** 
 264:main.c        **** 
 265:main.c        **** 
 266:main.c        **** 
 267:main.c        **** 
 268:main.c        **** 
 269:main.c        **** 
 270:main.c        **** 
GAS LISTING /tmp/ccNZ67a0.s 			page 8


 271:main.c        **** 
 272:main.c        **** 
 273:main.c        **** #if !defined(__AVR_ARCH__)
 274:main.c        ****  #error "__AVR_ARCH__ not defined!"
 275:main.c        **** #endif
 276:main.c        **** 
 277:main.c        **** //#include <string.h> //for strcmp
 278:main.c        **** 
 279:main.c        **** // WTF I left this as 15 bytes but wrote 256 via usbTinyI2c 
 280:main.c        **** // and had no errors (in version 20)?!
 281:main.c        **** //uint8_t edidArray[15]; 
 282:main.c        **** // = {0x00,0xe1,0xd2,0xc3,0xb4,0xa5,0x96,0x87,8,9};
 283:main.c        **** 
 284:main.c        **** 
 285:main.c        **** 
 286:main.c        **** 
 287:main.c        **** 
 288:main.c        **** //R,G,B
 289:main.c        **** volatile uint8_t ledState[3] = {0,0,0};
 290:main.c        **** uint8_t ledIndex = 0;
 291:main.c        **** 
 292:main.c        **** 
 293:main.c        **** #define EDIDARRAYLENGTH	128 //256
 294:main.c        **** 
 295:main.c        **** 
 296:main.c        **** //Initial values stolen (and modified) from HV121P01-101
 297:main.c        **** // Notes from SPWG spec 3.8
 298:main.c        **** uint8_t edidArray[EDIDARRAYLENGTH] =
 299:main.c        **** {
 300:main.c        **** 	//Addr	Data	//Values		Notes
 301:main.c        **** //EDID Header
 302:main.c        **** 	[0x00]=	0,		//				EDID Header
 303:main.c        **** 	[0x01]=	255,
 304:main.c        **** 	[0x02]=	255,
 305:main.c        **** 	[0x03]=	255,
 306:main.c        **** 	[0x04]=	255,
 307:main.c        **** 	[0x05]=	255,
 308:main.c        **** 	[0x06]=	255,
 309:main.c        **** 	[0x07]=	0,
 310:main.c        **** 
 311:main.c        **** //Vendor/ Product ID Stuff...
 312:main.c        **** 	//ID Manufacturer Name
 313:main.c        **** 	// SPWG: "EISA manufacture code = 3 character ID (compressed ASCII)
 314:main.c        **** 	// edidv3: "2-byte representation of the monitor's manufacturer.
 315:main.c        **** 	// 	This is the same as the EISA ID. Based on compressed ASCII,
 316:main.c        **** 	//    0001=A...11010=Z."
 317:main.c        **** 	//    Bit:    7   6   5   4   3   2   1   0
 318:main.c        **** 	//
 319:main.c        **** 	//    Byte 1: 0 | 4   3   2   1   0 | 4   3
 320:main.c        **** 	//            * |      char 1       | char 2
 321:main.c        **** 	//
 322:main.c        **** 	//    Byte 2: 2   1   0 | 4   3   2   1   0
 323:main.c        **** 	//            char 2    |      char 3
 324:main.c        **** 	//    "EISA manufacturer ID's are issued by Microsoft" YAY!
 325:main.c        **** 
 326:main.c        **** //Must be uppercase char1-3
 327:main.c        **** #define TOCOMPRESSEDASCII(char1,char2,char3) \
GAS LISTING /tmp/ccNZ67a0.s 			page 9


 328:main.c        **** 	      ((((char1)-'@')<<10) | (((char2)-'@')<<5) | ((char3)-'@'))
 329:main.c        **** #define TOCOMPRESSEDASCIIBYTE1(char1,char2,char3) \
 330:main.c        **** 	      ((TOCOMPRESSEDASCII(char1,char2,char3))>>8)
 331:main.c        **** #define TOCOMPRESSEDASCIIBYTE2(char1,char2,char3) \
 332:main.c        **** 	      ((TOCOMPRESSEDASCII(char1,char2,char3))&0xff)
 333:main.c        **** 	//[0x08]=	0x30,	//LEN			ID=LEN
 334:main.c        **** 	//[0x09]=	0xAE,	
 335:main.c        **** 	[0x08]=	TOCOMPRESSEDASCIIBYTE1('M','E','H'),
 336:main.c        **** 	[0x09]=	TOCOMPRESSEDASCIIBYTE2('M','E','H'),
 337:main.c        **** 
 338:main.c        **** 	//ID Product Code
 339:main.c        **** 	// SPWG: "Pannel Supplier Reserved - Product Code"
 340:main.c        **** 	// edidv3: "vendor-assigned product code"
 341:main.c        **** 	//[0x0A]=	0x05,	//SXGA+		SXGA+ FFS
 342:main.c        **** 	//[0x0B]=	0x40,
 343:main.c        **** 	// My first product...
 344:main.c        **** 	//  should report <0x01><PROJ_VER>
 345:main.c        **** 	//  e.g. 0x01 0x30, which is kinda like version 1.30
 346:main.c        **** 	//  yeah-no. PROJ_VER=30 is not 0x30 it's 30
 347:main.c        **** 	//
 348:main.c        **** #if ( (PROJ_VER > 99) || (MY_EDID_PRODUCT_NUM > 99) )
 349:main.c        ****  #error "TOBCD(val) doesn't work with values > 99..."
 350:main.c        ****  #error "...either Project Ver or Product Num: congrats on making it this far!"
 351:main.c        **** #endif
 352:main.c        **** 
 353:main.c        **** #warning "Using PROJ_VER as the display's product-code causes new versions"
 354:main.c        **** #warning " to no longer be compatible with SwitchResX's timings for the"
 355:main.c        **** #warning " old version... Something to contemplate..."
 356:main.c        **** 	[0x0A]=	TOBCD(PROJ_VER),
 357:main.c        **** 	[0x0B]=	TOBCD(MY_EDID_PRODUCT_NUM), //0x01,
 358:main.c        **** 
 359:main.c        **** 	//32-bit serial No.
 360:main.c        **** 	// (optional; 0 if unused)
 361:main.c        **** 	[0x0C]=	0x00,	//				(blank)
 362:main.c        **** 	[0x0D]=	0x00,
 363:main.c        **** 	[0x0E]=	0x00,
 364:main.c        **** 	[0x0F]=	0x00,
 365:main.c        **** 
 366:main.c        **** 	//Week of manufacture
 367:main.c        **** 	[0x10]=	0x00,	//				(blank)
 368:main.c        **** 	//Year of manufacture (offset from 1990)
 369:main.c        **** //	[0x11]=	16,	//2006		Manufactured in 2006
 370:main.c        **** 	[0x11]=  (COMPILE_YEAR - 1990),
 371:main.c        **** 
 372:main.c        **** //EDID Version Info "Panel ID structure version/revision"
 373:main.c        **** 	//EDID Structure Ver.
 374:main.c        **** 	[0x12]=	0x01,	//				EDID Ver 1.0
 375:main.c        **** 	//EDID Revision #
 376:main.c        **** 	[0x13]=	0x03,	//				EDID Rev 0.3 -- Same for E-EDID
 377:main.c        **** 
 378:main.c        **** //Display Parameters
 379:main.c        **** 	//Video input definition:
 380:main.c        **** 	// SPWG: "Vidio I/P definition = Digital I/P (0x80)"
 381:main.c        **** 	// 0x50 deduced from 0x50 = 80, assumed reversed in HV121 LCD specs...
 382:main.c        **** 	// But, apparently 0x80 was correct, according to SPWG
 383:main.c        **** 	// According to edidv3 "Digital input requires use of the EDID structure
 384:main.c        **** 	//  version 2" which doesn't appear to be the case (edidv3 is old?)
GAS LISTING /tmp/ccNZ67a0.s 			page 10


 385:main.c        **** 	// According to E-EDID Standard (newer?):
 386:main.c        **** 	// "Compatibility with monitors and systems that require EDID 
 387:main.c        **** 	//  structure 2 is achieved by allowing EDID structure 2 to 
 388:main.c        **** 	//  be included in E-EDID as two extensions residing at fixed locations"
 389:main.c        **** 	// Looking into E-EDID for now on...
 390:main.c        **** 	// Bit 7 = 1 : Digital
 391:main.c        **** 	//   Bits 6-1: Reserved = 0
 392:main.c        ****   	//   Bit 0:    "DFP 1.x" "If set=1, Interface is signal compatible
 393:main.c        **** 	//                        with VESA DFP 1.x: TMDS CRGB, 1pix/clk,
 394:main.c        **** 	//								  up to 8bits/color MSB aligned, DE active high"
 395:main.c        **** 	//             NOT SET...
 396:main.c        **** 	//             So maybe edidv3 was right....?
 397:main.c        **** 
 398:main.c        **** 	[0x14]=	0x80, //0x50,	//	"HEX=80 DEC=50" WTF?!			-------(????)
 399:main.c        **** 
 400:main.c        **** #define H_IMAGE_SIZE_CM ((H_IMAGE_SIZE_MM+5L)/10L)
 401:main.c        **** #if (H_IMAGE_SIZE_CM > 255)
 402:main.c        ****  #error "H_IMAGE_SIZE_CM is too large!"
 403:main.c        **** #endif
 404:main.c        **** 	//Max H image size (cm rounded)
 405:main.c        **** 	[0x15]=	((uint8_t)H_IMAGE_SIZE_CM), //25,	//				25cm
 406:main.c        **** 
 407:main.c        **** 	//Max V image size (rounded)
 408:main.c        **** 	[0x16]=	18,	//				18cm
 409:main.c        **** 
 410:main.c        **** 	//Display Gamma
 411:main.c        **** 	// = (gamma * 100)-100
 412:main.c        **** 	// e.g. (2.2*100)-100=120 (SPWG)
 413:main.c        **** 	[0x17]=	120,	//0x78=2.2	Gamma curve = 2.2
 414:main.c        **** 
 415:main.c        **** 	//Feature Support
 416:main.c        **** 	// SPWG: "no DPMS, Active Off, RGB, timing BLK 1 == 0x0A"
 417:main.c        **** 	// ????
 418:main.c        **** 	// Bits 7-5: standby, suspend, active-off
 419:main.c        **** 	// Bit 4-3: Display Type (b4=0, b3=1: RGB)
 420:main.c        **** 	// Bit 2: colorspace
 421:main.c        **** 	// Bit 1: Preferred Timing Mode
 422:main.c        **** 	//        "If this bit is set to 1, the display's preferred timing mode
 423:main.c        **** 	//         is indicated in the first detailed timing block.
 424:main.c        **** 	//         NOTE: Use of the preferred timing mode is required by
 425:main.c        **** 	//         EDID Structure version 1 Revision 3 and higher."
 426:main.c        **** 	// Bit 0: 0=GTF timings not supported
 427:main.c        **** 	[0x18]=	0x0A, //234,	//0xEA		RGB display, Preferred Timing Mode
 428:main.c        **** 	
 429:main.c        **** 
 430:main.c        **** 
 431:main.c        **** //Panel Color Coordinates
 432:main.c        **** 	//Red/Green low bits (RxRy/GxGy)
 433:main.c        **** 	[0x19]=	175,	//0xAF		--- Red/Green Low Bits
 434:main.c        **** 	//Blue/White low bits (BxBy/WxWy)
 435:main.c        **** 	[0x1A]=	64,	//0x40		--- Blue/White low bits
 436:main.c        **** 
 437:main.c        **** 	// Below:
 438:main.c        **** 	//  R/G/B/Wx = 0.xxx
 439:main.c        **** 	//  R/G/B/Wy = 0.xxx
 440:main.c        **** 	[0x1B]=	0x95,	// Red x high bits 95 149 0.584 
 441:main.c        **** 						// Red (x) = 10010101 (0.584) 
GAS LISTING /tmp/ccNZ67a0.s 			page 11


 442:main.c        **** 	[0x1C]=	0x56,	// Red y high bits 56 86 0.338 
 443:main.c        **** 						// Red (y) = 01010110 (0.338) 
 444:main.c        **** 	[0x1D]=	0x4A,	// Green x high bits 4A 74 0.292 
 445:main.c        **** 						// Green (x) = 01001010 (0.292) 
 446:main.c        **** 	[0x1E]=	0x8F,	// Green y high bits 8F 143 0.562 
 447:main.c        **** 						// Green (y) = 10001111 (0.562) 
 448:main.c        **** 	[0x1F]=	0x25,	// Blue x high bits 25 37 0.146 
 449:main.c        **** 						// Blue (x) = 00100101 (0.146) 
 450:main.c        **** 	[0x20]=	0x20,	// BLue y high bits 20 32 0.125 
 451:main.c        **** 						// Blue (y) = 00100000 (0.125) 
 452:main.c        **** 	[0x21]=	0x50,	// White x high bits 50 80 0.313 
 453:main.c        **** 						// White (x) = 01010000 (0.313) 
 454:main.c        **** 	[0x22]=	0x54,	// White y high bits 54 84 0.329 
 455:main.c        **** 						// White (y) = 01010100 (0.329) 
 456:main.c        **** 
 457:main.c        **** 
 458:main.c        **** //Established Timings
 459:main.c        **** 	// SPWG suggests 0x00 for all three: "not used"
 460:main.c        **** 	// "Also, if any one-bit flag is not set in the Established Timing 
 461:main.c        **** 	//  block, this data can not be used to determine if that timing is
 462:main.c        ****   	//  within the supported scanning frequency of the display - 
 463:main.c        **** 	//  only that it is not a Factory Supported Mode."
 464:main.c        **** 	// "Factory Supported Modes are defined as modes that are properly 
 465:main.c        **** 	//  sized and centered as the monitor is delivered from factory."
 466:main.c        **** 	// IOW: 0's is fine.
 467:main.c        **** 	//Established Timings I
 468:main.c        **** 	[0x23]=	0x00, //0x21,	// Established timing 1 21 33 ----
 469:main.c        **** 						// Bit 5: 640x480 @ 60Hz
 470:main.c        **** 						// Bit 0: 800x600 @ 60Hz
 471:main.c        **** 	//Established Timings II
 472:main.c        **** 	[0x24]=	0x00, //0x08,	// Established timing 2 08 8 ----
 473:main.c        **** 						// Bit 3: 1024x768 @ 60Hz
 474:main.c        **** 	//Established Timings III / Manufacturer's Timings
 475:main.c        **** 	// "Bits 6 → 0 (inclusive) of byte 3 are used to define manufacturer’s
 476:main.c        ****   	//  proprietary timings, and may be used if a manufacturer wants to 
 477:main.c        **** 	//  identify such timings through the use of one-bit flags."
 478:main.c        **** 	// NOT required, and not recommended.
 479:main.c        **** 	[0x25]=	0x00,	// Established timing 3 00 0 ----
 480:main.c        **** 
 481:main.c        **** //Standard Timing ID (SPWG suggests all = 0x01: "not used"
 482:main.c        **** 	//Standard Timing #1
 483:main.c        **** 	// These values don't make any sense! (from HV121 spec)
 484:main.c        **** 	// iBook LTN display lists none
 485:main.c        **** 	//[0x26]=	0x81,	// 81 129    HV121:"Not Used"
 486:main.c        **** 	//[0x27]=	0x80,	// 80 128 
 487:main.c        **** 	[0x26 ... 0x27]= 0x01, //Not Used
 488:main.c        **** 
 489:main.c        **** 	//Standard Timings #2-8 "Not Used"
 490:main.c        **** 	// (Each is a pair of bytes, as Timing #1 above)
 491:main.c        **** 	[0x28 ... 0x35]=	0x01,	// 01 1 
 492:main.c        **** 
 493:main.c        **** //Detailed Timing/Monitor Descriptor #1 (60Hz)
 494:main.c        **** //"The first descriptor block shall be used to indicate the display's 
 495:main.c        **** // preferred timing mode"
 496:main.c        **** 	// SPWG: Pixel Clock / 10,000
 497:main.c        **** 	//[0x36]=	0x20,	// LSB 84.80 MHz Main Clock
 498:main.c        **** 	//[0x37]=	0x21,	// MSB
GAS LISTING /tmp/ccNZ67a0.s 			page 12


 499:main.c        **** 	//LTD121: 51-57MHz 54typ
 500:main.c        **** 	// WORKING WITH IT DIRECTLY HERE...
 501:main.c        **** 	// (dual-pixel mode, with second pixel blank)
 502:main.c        **** 
 503:main.c        **** 	//This is per EDID standard:
 504:main.c        ****   #define CLK_SCALE   (10000L)
 505:main.c        **** 
 506:main.c        **** 	[0x36]=	((PIX_CLK/CLK_SCALE)&0xff),
 507:main.c        **** 	[0x37]=	((PIX_CLK/CLK_SCALE)>>8),
 508:main.c        **** 	// Horizontal
 509:main.c        **** 	//0x578 = 1400, 0x0C8 = 200
 510:main.c        **** 	// SPWG Note 2:
 511:main.c        **** 	// "HA, byte 38h, is true active pixels"
 512:main.c        **** 	// "HA_pixClks, bytes 55/56, is HA for XGA 
 513:main.c        **** 	//  and HA/2 for WSXGA+ and above resolutions" this seems to be in error
 514:main.c        **** 	//[0x38]=	0x78, //120, //0x78	Hor Active = 1400 lower 8bits
 515:main.c        **** 	//[0x39]=	0xC8, //200, //0xC8	Hor Blanking = 200 lower 8bits (Thbp)
 516:main.c        **** 	//[0x3A]=	((0x05<<4) | (0x00)),	//0x50 80
 517:main.c        **** 
 518:main.c        **** 	//4bits Hor Active + 4bits Hor Blanking upper4:4bits
 519:main.c        **** 	// In pixel-clocks
 520:main.c        **** 	[0x38]=	((H_ACTIVE)&0xff),
 521:main.c        **** 	[0x39]=	((H_BLANKING)&0xff),
 522:main.c        **** 	[0x3A]=	(((H_ACTIVE)&0xf00)>>4) | (((H_BLANKING)&0xf00)>>8),
 523:main.c        **** 
 524:main.c        **** 
 525:main.c        **** //#warning "LTD-DIRECT"
 526:main.c        **** // In lines
 527:main.c        **** #define V_ACTIVE		(V_ACTIVE_GPU) //1050
 528:main.c        **** #define V_BLANKING_TYP	(V_FP_GPU+V_WIDTH_GPU+V_BP_GPU) //16
 529:main.c        **** #define V_BLANKING (V_BLANKING_TYP)
 530:main.c        **** 	// Vertical
 531:main.c        **** 	//0x41A = 1050, 0x00A = 10
 532:main.c        **** 	//[0x3B]=	0x1A,	//26	Ver Active = 1050
 533:main.c        **** 	//[0x3C]=	0x0A, //10	Ver Blanking = 10 (Tvbp)
 534:main.c        **** 						// SPWG: "DE Blanking typ. For DE only panels" ???
 535:main.c        **** 	//[0x3D]=	((0x04<<4) | (0x00)),	//0x40 64
 536:main.c        **** 						//4bits Ver Active + 4bits Ver Blanking
 537:main.c        **** 	[0x3B]=  ((V_ACTIVE)&0xff),
 538:main.c        **** 	[0x3C]=  ((V_BLANKING)&0xff),
 539:main.c        **** 	[0x3D]=  (((V_ACTIVE)&0xf00)>>4) | (((V_BLANKING)&0xf00)>>8),
 540:main.c        **** 
 541:main.c        **** 
 542:main.c        **** 	//[0x3E]=	20,	//Hor Sync Offset = 20 pixels (Thfp)
 543:main.c        **** 						//"Pixels, from blanking starts, lower 8 bits"
 544:main.c        **** 	[0x3E]= ((THFP)&0xff),
 545:main.c        **** 
 546:main.c        **** 	//[0x3F]=	116,	//Hor Sync Pulse Width = 116 pixels
 547:main.c        **** 	[0x3F]= ((THW)&0xff),
 548:main.c        **** 
 549:main.c        **** 	//Vertical Sync Offset (TVFP)
 550:main.c        **** //#define TVFP_MIN	(V_FP_GPU) //0
 551:main.c        **** #define TVFP	(V_FP_GPU) //(TVFP_MIN + 2)
 552:main.c        **** 	//Vertical Sync Pulse Width
 553:main.c        **** //#define TVW_MIN	(V_WIDTH_GPU) //2
 554:main.c        **** #define TVW	(V_WIDTH_GPU) //(TVW_MIN*2)
 555:main.c        **** 	// HV121 spec seems to be misleading... should be (?)
GAS LISTING /tmp/ccNZ67a0.s 			page 13


 556:main.c        **** 	// [0x40]=((Voff&0x0f)<<4) | (Vpw&0x0f)
 557:main.c        **** 	// [0x41]=((Voff&0x30)<<6) | ((Vpw&0x30)<<4) 
 558:main.c        **** 	//        | (Hpw&0x300)>>6) | ((Hoff&0x300)>>8) --ish
 559:main.c        **** //	[0x40]=	37,	//0x25	2	Vert Sync Offset = 2 lines  ??? (Tvfp)
 560:main.c        **** 						//SPWG: "Offset=xx lines    Sync Width=xx lines"
 561:main.c        **** 	[0x40]=	(((TVFP)&0x0f)<<4) | ((TVW)&0x0f),
 562:main.c        **** 
 563:main.c        **** //	[0x41]=	0,		//0x00	5	Vert Sync Pulse Width = 5 lines
 564:main.c        **** 						//SPWG: "Horiz Vert Sync Offset/Width upper 2 bits"
 565:main.c        **** 
 566:main.c        **** #if( ((THFP)&0xffffff00)  )
 567:main.c        **** 	#error "Byte 0x41 (HSYNC/VSYNC Offset/Pulsewidth upper bits NYI"
 568:main.c        **** #endif
 569:main.c        **** 
 570:main.c        **** #if( ((THW)&0xffffff00)  )
 571:main.c        **** 	#error "Byte 0x41 (HSYNC/VSYNC Offset/Pulsewidth upper bits NYI"
 572:main.c        **** #endif
 573:main.c        **** 
 574:main.c        **** #if(  ((TVFP)&0xfffffff0)  )
 575:main.c        **** 	#error "Byte 0x41 (HSYNC/VSYNC Offset/Pulsewidth upper bits NYI"
 576:main.c        **** #endif
 577:main.c        **** 
 578:main.c        **** #if(  ((TVW)&0xfffffff0) )
 579:main.c        **** 	#error "Byte 0x41 (HSYNC/VSYNC Offset/Pulsewidth upper bits NYI"
 580:main.c        **** #endif
 581:main.c        **** 
 582:main.c        **** 
 583:main.c        **** 	[0x41]=	0,
 584:main.c        **** 
 585:main.c        **** #if (H_IMAGE_SIZE_MM > 0xff)
 586:main.c        **** 	#error "LCDreIDer doesn't yet parse H_IMAGE_SIZE_MM > 255"
 587:main.c        **** 	#error "It should be a simple modification..."
 588:main.c        **** #else
 589:main.c        **** 	#define H_IMAGE_SIZE_MM_LOWBYTE	H_IMAGE_SIZE_MM
 590:main.c        **** #endif
 591:main.c        **** 
 592:main.c        **** #if (V_IMAGE_SIZE_MM > 0xff)
 593:main.c        **** 	#error "LCDreIDer doesn't yet parse V_IMAGE_SIZE_MM > 255"
 594:main.c        **** 	#error "It should be a simple modification..."
 595:main.c        **** #else
 596:main.c        **** 	#define V_IMAGE_SIZE_MM_LOWBYTE	V_IMAGE_SIZE_MM
 597:main.c        **** #endif
 598:main.c        **** 
 599:main.c        **** 
 600:main.c        **** 	[0x42]=	H_IMAGE_SIZE_MM_LOWBYTE,
 601:main.c        **** 	[0x43]=	V_IMAGE_SIZE_MM_LOWBYTE,
 602:main.c        **** 		//0xB8,	//Vertical Image Size = 184mm (low 8 bits)
 603:main.c        **** 	[0x44]=	0x00,	// 4 bits of Hor Image Size + 4 bits of Ver Image Size
 604:main.c        **** 	[0x45]=	0x00,	//Horizontal Border = 0 pixels
 605:main.c        **** 	[0x46]=	0x00,	//Vertical Border = 0 lines
 606:main.c        **** 
 607:main.c        **** 	//Flags (bits 6,5,4,3 repurpose other bits! Don't change)
 608:main.c        **** 	// Bit7:		0=Non-Interlaced
 609:main.c        **** 	// Bit6,5:	00=non-stereo
 610:main.c        **** 	// Bit4,3:	11=Digital Separate (as opposed to composite)
 611:main.c        **** 	// Bit2:		Vertical Polarity: 1=Vsync is positive
 612:main.c        **** 	// Bit1:		Horizontal Polarity: 1=Hsync is positive
GAS LISTING /tmp/ccNZ67a0.s 			page 14


 613:main.c        **** 	// Bit0:		x (don't care, when non-stereo) E-EDID WTF See below, SPWG:
 614:main.c        **** 	//[0x47]=	0x19,	// ----- ????
 615:main.c        **** 						// SPWG: "Non-interlaced, Normal, no stereo, Separate
 616:main.c        **** 						//        sync, H/V pol Negatives" = 18
 617:main.c        **** 						//       "DE only note: LSB is set to '1' if panel is
 618:main.c        **** 						//        DE-timing only. H/V can be ignored" = 19
 619:main.c        **** 						// Indeed: HV121 specs seem to be DE-only
 620:main.c        **** 						//        "Features: Data enable signal mode"
 621:main.c        **** 						//        Also, timing diagrams do not show H/V
 622:main.c        **** 	[0x47]=	0x18,
 623:main.c        **** 
 624:main.c        **** 
 625:main.c        **** //E-EDID:
 626:main.c        **** //Notes regarding EDID Monitor Range Limits Descriptor:
 627:main.c        **** //		Use of this descriptor is mandatory. 
 628:main.c        **** //		Any timing outside these limits may cause the monitor to enter a 
 629:main.c        **** //		self-protection mode. The host shall always verify that an intended 
 630:main.c        **** //		timing falls within these limits before the timing is applied.
 631:main.c        **** // My Notes:
 632:main.c        **** //  This does not seem to be implemented in any of the displays 
 633:main.c        **** //  I've checked.
 634:main.c        **** //  Nor is it mentioned in SPWG
 635:main.c        **** //But E-EDID mentions it twice!
 636:main.c        **** // 1) All blocks shall be filled with valid data using the formats
 637:main.c        **** //		described in sections 3.10.2 and 3.10.3.  Use of a data 
 638:main.c        **** //		fill pattern is not permitted. 
 639:main.c        **** // 2) Timing data must represent a supported mode of the display. 
 640:main.c        **** //	3) Descriptor blocks shall be ordered such that all detailed timing
 641:main.c        **** //		blocks precede other  types of descriptor blocks 
 642:main.c        **** //	4) The first descriptor block shall be used to indicate the display's
 643:main.c        **** //		preferred timing mode.  This is described in section 3.10.1 
 644:main.c        **** //	5) A Monitor Range Limits Descriptor must be provided 
 645:main.c        **** //	6) A Monitor Name Descriptor must be provided 
 646:main.c        **** //Note:  Items 4, 5 and 6 above were permitted but not required prior to 
 647:main.c        **** //		EDID structure version 1 revision 3.  Hosts may encounter displays 
 648:main.c        **** //		using EDID version 1 revision 0-2 which do not meet all of these 
 649:main.c        **** //		requirements.
 650:main.c        **** // Yeah, but All the screens I've checked report to be EDID V1R3...
 651:main.c        **** 
 652:main.c        **** 
 653:main.c        **** 
 654:main.c        **** // Detailed timing/monitor descriptor #2 Alternative Panel Timing 
 655:main.c        **** 	// SPWG: "Timing Descriptor #2 may be used for timings other than 60Hz"
 656:main.c        **** 	// HV121: (dummy)
 657:main.c        **** 	//SPWG shows Timing Descriptor #2 as identically-formatted to #1
 658:main.c        **** 	// With the exception of the last byte...
 659:main.c        **** 	//  byte 0x59 "Module 'A' Revision = Example 00, 01, 02, 03, etc."
 660:main.c        **** 	// (isn't the info from Timing1's last byte necessary here too?!)
 661:main.c        **** #if (!defined(ALT_TIMING) || !ALT_TIMING)
 662:main.c        **** 	[0x48 ... 0x4A] = 0,
 663:main.c        **** 	[0x4B]=	0x10,	// Dummy Descriptor
 664:main.c        **** 	[0x4C ... 0x59] = 0,
 665:main.c        **** #else
 666:main.c        **** 	//These are identical to Timing Descriptor #1, bytes 0x36-0x47
 667:main.c        **** 	//with the exception of byte 0x59... (TBD)
 668:main.c        **** 	// AND timing macros are suffixed with _ALT,
 669:main.c        **** 	// e.g. PIX_CLK -> PIX_CLK_ALT
GAS LISTING /tmp/ccNZ67a0.s 			page 15


 670:main.c        **** 
 671:main.c        **** 	[0x48]=	((PIX_CLK_GPU_ALT/CLK_SCALE)&0xff),
 672:main.c        **** 	[0x49]=	((PIX_CLK_GPU_ALT/CLK_SCALE)>>8),
 673:main.c        **** 
 674:main.c        **** 	[0x4A]=	((H_ACTIVE_GPU_ALT)&0xff),
 675:main.c        **** 	[0x4B]=	((H_BLANKING_ALT)&0xff),
 676:main.c        **** 	[0x4C]=	(((H_ACTIVE_GPU_ALT)&0xf00)>>4) | \
 677:main.c        **** 				(((H_BLANKING_ALT)&0xf00)>>8),
 678:main.c        **** 
 679:main.c        **** 	[0x4D]=  ((V_ACTIVE_GPU_ALT)&0xff),
 680:main.c        **** 	[0x4E]=  ((V_BLANKING_ALT)&0xff),
 681:main.c        **** 	[0x4F]=  (((V_ACTIVE_GPU_ALT)&0xf00)>>4) | \
 682:main.c        **** 				(((V_BLANKING_ALT)&0xf00)>>8),
 683:main.c        **** 
 684:main.c        **** 	[0x50]= ((H_FP_GPU_ALT)&0xff),
 685:main.c        **** 	[0x51]= ((H_WIDTH_GPU_ALT)&0xff),
 686:main.c        **** 	[0x52]= (((V_FP_GPU_ALT)&0x0f)<<4) | ((V_WIDTH_GPU_ALT)&0x0f),
 687:main.c        **** 
 688:main.c        **** #if(H_FP_GPU_ALT > 0xff)
 689:main.c        **** #error "H_FP_GPU_ALT > 0xff is not yet implemented"
 690:main.c        **** #endif
 691:main.c        **** #if (H_WIDTH_GPU_ALT > 0xff)
 692:main.c        **** #error "H_WIDTH_GPU_ALT > 0xff is not yet implemented"
 693:main.c        **** #endif
 694:main.c        **** #if (V_FP_GPU_ALT > 0xf)
 695:main.c        **** #error "V_FP_GPU_ALT > 0xf is not yet implemented"
 696:main.c        **** #endif
 697:main.c        **** #if (V_WIDTH_GPU_ALT > 0xf)
 698:main.c        **** #error "V_WIDTH_GPU_ALT > 0xf is not yet implemented"
 699:main.c        **** #endif
 700:main.c        **** 	[0x53]=	0, //Upper bits are not implemented
 701:main.c        **** 
 702:main.c        **** 	[0x54]=	H_IMAGE_SIZE_MM_LOWBYTE,
 703:main.c        **** 	[0x55]=	V_IMAGE_SIZE_MM_LOWBYTE,
 704:main.c        **** 		//0xB8,	//Vertical Image Size = 184mm (low 8 bits)
 705:main.c        **** 	[0x56]=	0x00,	// 4 bits of Hor Image Size + 4 bits of Ver Image Size
 706:main.c        **** 	[0x57]=	0x00,	//Horizontal Border = 0 pixels
 707:main.c        **** 	[0x58]=	0x00,	//Vertical Border = 0 lines
 708:main.c        **** 
 709:main.c        **** 
 710:main.c        **** 	//This byte is different from 0x47, according to spwg:
 711:main.c        **** 	// "Module “A” Revision =          Example: 00, 01, 02, 03, etc."
 712:main.c        **** 	// (Doesn't it need DE, polarity, etc?!)
 713:main.c        **** 	[0x59]=	0,
 714:main.c        **** #endif
 715:main.c        **** // Detailed timing/monitor descriptor #3
 716:main.c        **** 	//SPWG: Shows #3 as same-format as HV121's #4
 717:main.c        **** 	// SPWG notes placed there
 718:main.c        **** 	// SPWG apparently doesn't have a descriptor matching this one...
 719:main.c        **** 	//[0x5A ... 0x5C] = 0,	//SPWG: "Flag" (all 0)
 720:main.c        **** 	//[0x5D]=	0x0F,	//Manufacturer Specified
 721:main.c        **** 						//  SPWG: Dummy Descriptor=0xFE
 722:main.c        **** 	//[0x5E]=	0x00,	//
 723:main.c        **** 	//[0x5F]=	144,	//1440
 724:main.c        **** 	//[0x60]=	0x43,	//4:3
 725:main.c        **** 	//[0x61]=	50,	//50Hz
 726:main.c        **** 	//[0x62 ... 0x64] = 0,	//"Not Supported"
GAS LISTING /tmp/ccNZ67a0.s 			page 16


 727:main.c        **** 	//[0x65]=	19,	//190 (what?)
 728:main.c        **** 	//[0x66]=	2,		//FFS (what??)
 729:main.c        **** 	//[0x67]=	0,		//"Reserved"
 730:main.c        **** 	// BOE ???
 731:main.c        **** 	//[0x68]=	0x09,
 732:main.c        **** 	//[0x69]=	0xE5,	
 733:main.c        **** 	//[0x6A ... 0x6B] = 0,
 734:main.c        **** 
 735:main.c        **** 	//Adding another Dummy Descriptor:
 736:main.c        **** 	[0x5A ... 0x5C] = 0,
 737:main.c        **** 	[0x5D] = 0x10,
 738:main.c        **** 	[0x5E ... 0x6B] = 0,
 739:main.c        **** 
 740:main.c        **** // Detailed timing/monitor descriptor #4
 741:main.c        **** 	// Product Name Tag (ASCII)
 742:main.c        **** 	[0x6C ... 0x6E] = 0x00,	//SPWG: "Flag"
 743:main.c        **** 	[0x6F]= 0xFC,	//Let's make this a monitor-name instead of ASCII Data	
 744:main.c        **** 			//0xFE,				//SPWG: "Dummy Descriptor" NOT: FE = ASCII Data
 745:main.c        **** 	[0x70]=	0x00,				//SPWG: "Flag"
 746:main.c        **** 
 747:main.c        **** 	// Model Name: mehLTD121KM7K //HV121P01-101
 748:main.c        **** 	[0x71]=	'm', //'H',				//SPWG: PC Maker P/N 1st Character
 749:main.c        **** 	[0x72]=	'e', //'V',				//SPWG: PC Maker P/N 2nd Character
 750:main.c        **** 	[0x73]=	'h', //'1',				//SPWG: PC Maker P/N 3rd Character
 751:main.c        **** 	[0x74]=	'L', //'2',				//SPWG: PC Maker P/N 4th Character
 752:main.c        **** 	[0x75]=	'T', //'1',				//SPWG: PC Maker P/N 5th Character
 753:main.c        **** 	[0x76]=	'D', //'P',				//SPWG: LCD Supplier Revision #
 754:main.c        **** 	[0x77]=	'1', //'0',				//SPWG: Manufacturer P/N
 755:main.c        **** 	[0x78]=	'2', //'1',				//SPWG: Manufacturer P/N
 756:main.c        **** 	[0x79]=	'1', //'-',				//SPWG: Manufacturer P/N
 757:main.c        **** 	[0x7A]=	'K', //'1',				//SPWG: Manufacturer P/N
 758:main.c        **** 	[0x7B]=	'M', //'0',				//SPWG: Manufacturer P/N
 759:main.c        **** 	[0x7C]=	'7', //'1',				//SPWG: Manufacturer P/N
 760:main.c        **** 	[0x7D]=	'K', //0x0A,				//SPWG: Manufacturer P/N
 761:main.c        **** 									//SPWG: "(if <13 char, terminate with ASCII
 762:main.c        **** 									//       code 0Ah, set remaining char = 20h"
 763:main.c        **** 									// Apparently referring to ALL characters
 764:main.c        **** 									//   0x71-0x7D
 765:main.c        **** 
 766:main.c        **** 	//SPWG Timing Descriptor #4:
 767:main.c        **** 	//0x6C-6E	0x00	Flag
 768:main.c        **** 	//0x6F		0xFE	Data Type Tag
 769:main.c        **** 	//0x70		0x00	Flag
 770:main.c        **** 	//0x71-75	XX		SMBUS Value = XX nits
 771:main.c        **** 	//0x76-77	XXX	SMBUS Value = XXX nits
 772:main.c        **** 	//0x78		XXX	SMBUS Value = max nits (Typically 00h, XXX nits)
 773:main.c        **** 	//0x79		1/2	Number of LVDS channels (1 or 2)
 774:main.c        **** 	//0x7A		0/1	Panel Self Test (00-not present, 01-present)
 775:main.c        **** 	//0x7B      0Ah	(less than 13 char, so terminate)
 776:main.c        **** 	//0x7C-7D	20h	(remaining characters, terminated above)
 777:main.c        **** 
 778:main.c        **** //The End.
 779:main.c        **** 	[0x7E]=	0,		//"Extension Flag"
 780:main.c        **** 						//SPWG: "Number of optional 128 panel ID extension blocks
 781:main.c        **** 						//      to follow, Typ=0"
 782:main.c        **** 	[0x7F]=	0x75	// CHECKSUM
 783:main.c        **** 						//SPWG: "The 1-byte sum of all 128 bytes in this panel
GAS LISTING /tmp/ccNZ67a0.s 			page 17


 784:main.c        **** 						//       ID block shall = 0"
 785:main.c        **** };
 786:main.c        **** 
 787:main.c        **** 
 788:main.c        **** uint8_t edidArrayIndex = 0;
 789:main.c        **** //Called immediately by the i2c interrupts when a byte is received
 790:main.c        **** static __inline__
 791:main.c        **** void processReceivedByte(uint8_t receivedByte, uint8_t byteNum)
 792:main.c        **** 	__attribute__((__always_inline__));
 793:main.c        **** //Called immediately by the i2c interrupts when a byte is to be loaded
 794:main.c        **** // for transmission
 795:main.c        **** static __inline__
 796:main.c        **** uint8_t nextByteToTransmit(uint8_t masterACKed)
 797:main.c        **** 	__attribute__((__always_inline__));;
 798:main.c        **** 
 799:main.c        **** 
 800:main.c        **** 
 801:main.c        **** 
 802:main.c        **** #define USICNT_MASK ((1<<USICNT3)|(1<<USICNT2)|(1<<USICNT1)|(1<<USICNT0))
 803:main.c        **** // There are four basic states: 
 804:main.c        **** //    Awaiting Start Condition
 805:main.c        **** //    ACK Transmission
 806:main.c        **** //		Address
 807:main.c        **** //    Data (read/write)
 808:main.c        **** // AWAITING values are set... others are read... (helps for readability)
 809:main.c        **** #define USI_STATE_AWAITING_START		0
 810:main.c        **** #define USI_STATE_AWAITING_START_SCL 1
 811:main.c        **** #define USI_STATE_START_SCL_RECEIVED USI_STATE_AWAITING_START_SCL
 812:main.c        **** #define USI_STATE_AWAITING_ADDRESS	2
 813:main.c        **** #define USI_STATE_ADDRESS_RECEIVED 	USI_STATE_AWAITING_ADDRESS	
 814:main.c        **** #define USI_STATE_AWAITING_ACK		3
 815:main.c        **** #define USI_STATE_ACK_COMPLETE		USI_STATE_AWAITING_ACK
 816:main.c        **** #define USI_STATE_AWAITING_BYTE	   4
 817:main.c        **** #define USI_STATE_BYTE_COMPLETE		USI_STATE_AWAITING_BYTE
 818:main.c        **** 
 819:main.c        **** //uint8_t usi_i2c_deviceAddressReceived = FALSE;
 820:main.c        **** uint8_t usi_i2c_byteToTransmit = 0xff; //0xA5;
 821:main.c        **** uint8_t usi_i2c_state = USI_STATE_AWAITING_START;
 822:main.c        **** uint8_t usi_i2c_readFromSlave = 0;
 823:main.c        **** uint8_t usi_i2c_requestedAddres = 0;
 824:main.c        **** uint8_t usi_i2c_receivedByte = 0;
 825:main.c        **** 
 826:main.c        **** #define SDA_PIN	PB0
 827:main.c        **** #define SCL_PIN	PB2
 828:main.c        **** #define SDAPORT	PORTB
 829:main.c        **** #define SCLPORT	PORTB
 830:main.c        **** 
 831:main.c        **** // This can be called in two cases:
 832:main.c        **** //   upon INIT
 833:main.c        **** //   and when a different slave has been addressed
 834:main.c        **** //      from an overflow interrupt
 835:main.c        **** void usi_i2c_awaitStart(void)
 836:main.c        **** {
 130               		.stabn	68,0,836,.LM0-.LFBB1
 131               	.LM0:
 132               	.LFBB1:
 133               	/* prologue: function */
GAS LISTING /tmp/ccNZ67a0.s 			page 18


 134               	/* frame size = 0 */
 135               	/* stack size = 0 */
 136               	.L__stack_usage = 0
 837:main.c        **** 	usi_i2c_state = USI_STATE_AWAITING_START;
 137               		.stabn	68,0,837,.LM1-.LFBB1
 138               	.LM1:
 139 0000 1092 0000 		sts usi_i2c_state,__zero_reg__
 838:main.c        **** 
 839:main.c        ****    //Clear the interrupt flags, etc. first...
 840:main.c        **** 	// NOTE This will release SCL hold (i.e. different slave addressed)
 841:main.c        ****    USISR = (1<<USISIF) //Start Condition Interrupt Flag
 140               		.stabn	68,0,841,.LM2-.LFBB1
 141               	.LM2:
 142 0004 80EE      		ldi r24,lo8(-32)
 143 0006 8EB9      		out 0xe,r24
 842:main.c        ****                        //  (ONLY cleared when written 1)
 843:main.c        ****          | (1<<USIOIF) //Counter Overflow Interrupt Flag
 844:main.c        ****                        //  (ONLY cleared when written 1)
 845:main.c        ****          | (1<<USIPF)  //Stop Condition Flag (not an interrupt)
 846:main.c        ****          | (0<<USIDC)  //Data Collision Flag (Read-Only, not an interrupt)
 847:main.c        ****          | (USICNT_MASK & 0); //Clear the USI counter
 848:main.c        **** 
 849:main.c        **** 
 850:main.c        ****    //Configure the USI to look for Start-Condition
 851:main.c        ****    USICR = (1<<USISIE) //Enable the start-condition interrupt
 144               		.stabn	68,0,851,.LM3-.LFBB1
 145               	.LM3:
 146 0008 88EA      		ldi r24,lo8(-88)
 147 000a 8DB9      		out 0xd,r24
 852:main.c        ****          | (0<<USIOIE) //Disable the counter-overflow interrupt
 853:main.c        ****          | (1<<USIWM1) //Enable two-wire mode 
 854:main.c        **** 							  // with SCL hold during start-condition
 855:main.c        ****          | (0<<USIWM0) // without SCL hold during overflow
 856:main.c        **** 							  // will be set later
 857:main.c        ****          | (1<<USICS1) //Select external clocking
 858:main.c        ****          | (0<<USICS0) //  positive-edge
 859:main.c        ****          | (0<<USICLK) //  4-bit counter counts on both external edges
 860:main.c        ****          | (0<<USITC); // DON'T toggle the clock pin 
 861:main.c        ****                        // (this should always be 0)
 862:main.c        **** 
 863:main.c        **** 	setpinPORT(SDA_PIN, SDAPORT);
 148               		.stabn	68,0,863,.LM4-.LFBB1
 149               	.LM4:
 150 000c C09A      		sbi 0x18,0
 864:main.c        **** 	setpinPORT(SCL_PIN, SCLPORT);
 151               		.stabn	68,0,864,.LM5-.LFBB1
 152               	.LM5:
 153 000e C29A      		sbi 0x18,2
 865:main.c        **** 
 866:main.c        **** 	setinPORT(SDA_PIN, SDAPORT);
 154               		.stabn	68,0,866,.LM6-.LFBB1
 155               	.LM6:
 156 0010 B898      		cbi 0x17,0
 867:main.c        **** 	//Enable SCL-hold during the start-condition 
 868:main.c        **** 	setoutPORT(SCL_PIN, SCLPORT);
 157               		.stabn	68,0,868,.LM7-.LFBB1
 158               	.LM7:
GAS LISTING /tmp/ccNZ67a0.s 			page 19


 159 0012 BA9A      		sbi 0x17,2
 160 0014 0895      		ret
 161               		.size	usi_i2c_awaitStart, .-usi_i2c_awaitStart
 162               	.Lscope1:
 163               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 164               		.stabd	78,0,0
 165               		.stabs	"usi_i2c_awaitStartSCL:F(0,49)",36,0,882,usi_i2c_awaitStartSCL
 166               	.global	usi_i2c_awaitStartSCL
 167               		.type	usi_i2c_awaitStartSCL, @function
 168               	usi_i2c_awaitStartSCL:
 169               		.stabd	46,0,0
 869:main.c        **** }
 870:main.c        **** 
 871:main.c        **** 
 872:main.c        **** 
 873:main.c        **** //Initialize the counter to count
 874:main.c        **** //Clear the counter-overflow flag to
 875:main.c        **** //Release SCL
 876:main.c        **** // 16 clock edges will signal 8 bits received (count=0)
 877:main.c        **** // 2 clock edges will signal ACK transmitted (count=14)
 878:main.c        **** #define USI_I2C_OVERFLOW_RELEASE_SCL_AND_SET_COUNTER(count) \
 879:main.c        ****    (USISR = ((1<<USIOIF) | (USICNT_MASK & (count))))
 880:main.c        **** 
 881:main.c        **** //This is called after a start-condition
 882:main.c        **** void usi_i2c_awaitStartSCL(void)
 883:main.c        **** {
 170               		.stabn	68,0,883,.LM8-.LFBB2
 171               	.LM8:
 172               	.LFBB2:
 173               	/* prologue: function */
 174               	/* frame size = 0 */
 175               	/* stack size = 0 */
 176               	.L__stack_usage = 0
 884:main.c        **** 	usi_i2c_state = USI_STATE_AWAITING_START_SCL;
 177               		.stabn	68,0,884,.LM9-.LFBB2
 178               	.LM9:
 179 0016 81E0      		ldi r24,lo8(1)
 180 0018 8093 0000 		sts usi_i2c_state,r24
 885:main.c        **** 
 886:main.c        **** 	//Before enabling the counter-overflow interrupt
 887:main.c        **** 	// make sure the flag is clear
 888:main.c        **** 	// this will also clear the counter... watch out!
 889:main.c        **** 	USISR = (1<<USIOIF);
 181               		.stabn	68,0,889,.LM10-.LFBB2
 182               	.LM10:
 183 001c 80E4      		ldi r24,lo8(64)
 184 001e 8EB9      		out 0xe,r24
 890:main.c        **** 
 891:main.c        ****    //Configure the USI to look for counter-overflow (start SCL received)
 892:main.c        ****    USICR = (1<<USISIE) //Enable the start-condition interrupt
 185               		.stabn	68,0,892,.LM11-.LFBB2
 186               	.LM11:
 187 0020 88EF      		ldi r24,lo8(-8)
 188 0022 8DB9      		out 0xd,r24
 893:main.c        ****          | (1<<USIOIE) //Enable the counter-overflow interrupt
 894:main.c        ****                        // WE'RE READY!!!
 895:main.c        ****          | (1<<USIWM1) //Enable two-wire mode
GAS LISTING /tmp/ccNZ67a0.s 			page 20


 896:main.c        ****          | (1<<USIWM0) // with SCL hold during overflow
 897:main.c        ****          | (1<<USICS1) //Select external clocking
 898:main.c        ****          | (0<<USICS0) //  positive-edge
 899:main.c        ****          | (0<<USICLK) //  4-bit counter counts on both external edges
 900:main.c        ****          | (0<<USITC); // DON'T toggle the clock pin 
 901:main.c        ****                        // (this should always be 0)
 902:main.c        **** 
 903:main.c        **** 	//Don't clear the USISIF, SCL should be released AFTER it's received!
 904:main.c        **** 	// ONE SCL change (high to low) should be counted before we're
 905:main.c        **** 	//   before we're ready for 16 edges signalling address+r/w received
 906:main.c        **** 	//APPARENTLY the USI_START_vect ISR is called until USISIF is cleared
 907:main.c        **** 	// Unless the start-SCL occurs before the overflow interrupt is enabled
 908:main.c        **** 	//  this should have the same effect (the overflow interrupt stalls SCL)
 909:main.c        **** 	// However, if the start-SCL is too fast to detect, then we're screwed
 910:main.c        **** 	// all of, what, an interrupt-jump and a few instructions?
 911:main.c        **** 	//  Maybe revisit the zipped version (using a while loop instead of
 912:main.c        **** 	//   states)
 913:main.c        **** 	// also inline this function...
 914:main.c        **** 	USISR = (1<<USISIF) | (USICNT_MASK & 15);
 189               		.stabn	68,0,914,.LM12-.LFBB2
 190               	.LM12:
 191 0024 8FE8      		ldi r24,lo8(-113)
 192 0026 8EB9      		out 0xe,r24
 193 0028 0895      		ret
 194               		.size	usi_i2c_awaitStartSCL, .-usi_i2c_awaitStartSCL
 195               	.Lscope2:
 196               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 197               		.stabd	78,0,0
 198               		.stabs	"usi_i2c_slaveInit:F(0,49)",36,0,925,usi_i2c_slaveInit
 199               	.global	usi_i2c_slaveInit
 200               		.type	usi_i2c_slaveInit, @function
 201               	usi_i2c_slaveInit:
 202               		.stabd	46,0,0
 915:main.c        **** 	
 916:main.c        **** //	USISR = (USICNT_MASK & 15);
 917:main.c        **** //	static uint8_t callCount = 0;
 918:main.c        **** //	if(callCount < 15)
 919:main.c        **** //		callCount++;
 920:main.c        **** //	set_heartBlink(callCount);
 921:main.c        **** }
 922:main.c        **** 
 923:main.c        **** 
 924:main.c        **** 
 925:main.c        **** void usi_i2c_slaveInit(void)
 926:main.c        **** {
 203               		.stabn	68,0,926,.LM13-.LFBB3
 204               	.LM13:
 205               	.LFBB3:
 206               	/* prologue: function */
 207               	/* frame size = 0 */
 208               	/* stack size = 0 */
 209               	.L__stack_usage = 0
 927:main.c        **** 	usi_i2c_awaitStart();
 210               		.stabn	68,0,927,.LM14-.LFBB3
 211               	.LM14:
 212 002a 00C0      		rjmp usi_i2c_awaitStart
 213               		.size	usi_i2c_slaveInit, .-usi_i2c_slaveInit
GAS LISTING /tmp/ccNZ67a0.s 			page 21


 214               	.Lscope3:
 215               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 216               		.stabd	78,0,0
 217               		.stabs	"__vector_13:F(0,49)",36,0,932,__vector_13
 218               	.global	__vector_13
 219               		.type	__vector_13, @function
 220               	__vector_13:
 221               		.stabd	46,0,0
 928:main.c        **** }
 929:main.c        **** 
 930:main.c        **** uint8_t heartBlinkInternal = 0;
 931:main.c        **** 
 932:main.c        **** ISR(USI_START_vect)
 933:main.c        **** {
 222               		.stabn	68,0,933,.LM15-.LFBB4
 223               	.LM15:
 224               	.LFBB4:
 225 002c 1F92      		push r1
 226 002e 0F92      		push r0
 227 0030 0FB6      		in r0,__SREG__
 228 0032 0F92      		push r0
 229 0034 1124      		clr __zero_reg__
 230 0036 2F93      		push r18
 231 0038 3F93      		push r19
 232 003a 4F93      		push r20
 233 003c 5F93      		push r21
 234 003e 6F93      		push r22
 235 0040 7F93      		push r23
 236 0042 8F93      		push r24
 237 0044 9F93      		push r25
 238 0046 AF93      		push r26
 239 0048 BF93      		push r27
 240 004a EF93      		push r30
 241 004c FF93      		push r31
 242               	/* prologue: Signal */
 243               	/* frame size = 0 */
 244               	/* stack size = 15 */
 245               	.L__stack_usage = 15
 934:main.c        **** 	// The start condition interrupt occurs when SDA is pulled low
 935:main.c        **** 	//   WHEN SCL is high...
 936:main.c        **** 	// Which means that the device will count an edge when SCL goes low...
 937:main.c        **** 	//   Thus, the number of clock edges will be 17 for the first 8 bits!!!
 938:main.c        **** 	//THIS IS A HACK AND SHOULD NOT BE IMPLEMENTED:
 939:main.c        **** //	while(getpinPORT(SCL_PIN, SCLPORT))
 940:main.c        **** //	{};
 941:main.c        **** 	// Should be fixed now, with the new AWAITING_START_SCL state
 942:main.c        **** 
 943:main.c        **** 	heartBlinkInternal++;
 246               		.stabn	68,0,943,.LM16-.LFBB4
 247               	.LM16:
 248 004e 8091 0000 		lds r24,heartBlinkInternal
 249 0052 8F5F      		subi r24,lo8(-(1))
 250 0054 8093 0000 		sts heartBlinkInternal,r24
 944:main.c        **** 	//set_heartBlink(heartBlinkInternal);
 945:main.c        **** 
 946:main.c        **** 	//A Start-Detection has occurred
 947:main.c        **** 	// The slaves (including this device) have pulled SCL low
GAS LISTING /tmp/ccNZ67a0.s 			page 22


 948:main.c        **** 	// (from the manual):
 949:main.c        **** 	//  The start detector will hold the SCL line low after the master has
 950:main.c        **** 	//  forced a negative edge on this line. This allows the slave to wake
 951:main.c        **** 	//  up from sleep or complete other tasks before setting up the USI 
 952:main.c        **** 	//  Data Register to receive the address. This is done by clearing the 
 953:main.c        **** 	//  start condition flag and resetting the counter. 
 954:main.c        **** 
 955:main.c        **** 	//NOT CERTAIN this is necessary
 956:main.c        **** 	// Shouldn't be, since the pin is set as an input...
 957:main.c        **** 	//   unless a START is received in the middle of a slave-write???
 958:main.c        **** 	// From the diagram showing the connections of the shift-registers
 959:main.c        **** 	// it seems we need this to prevent data collision
 960:main.c        **** 	//setinPORT(SDA_PIN, SDAPORT);
 961:main.c        **** 	//USIDR = 0xff;	
 962:main.c        **** 
 963:main.c        **** 	//Set the pin directions...
 964:main.c        **** 	// Make sure, just in case a start-condition interrupts a slave-write...
 965:main.c        **** 	setinPORT(SDA_PIN, SDAPORT);
 251               		.stabn	68,0,965,.LM17-.LFBB4
 252               	.LM17:
 253 0058 B898      		cbi 0x17,0
 966:main.c        **** 	// Leave the CLOCK pin active for SCL-hold at the first overflow
 967:main.c        **** 	// (once we've received address/direction)
 968:main.c        **** 	setoutPORT(SCL_PIN, SDAPORT);
 254               		.stabn	68,0,968,.LM18-.LFBB4
 255               	.LM18:
 256 005a BA9A      		sbi 0x17,2
 969:main.c        **** 
 970:main.c        **** 	//Indicate that the address hasn't yet been received
 971:main.c        **** 	// (it should be the first byte transmitted)
 972:main.c        **** 	usi_i2c_awaitStartSCL();
 257               		.stabn	68,0,972,.LM19-.LFBB4
 258               	.LM19:
 259 005c 00D0      		rcall usi_i2c_awaitStartSCL
 260               	/* epilogue start */
 973:main.c        **** 
 974:main.c        **** 	//heartClear();
 975:main.c        **** }
 261               		.stabn	68,0,975,.LM20-.LFBB4
 262               	.LM20:
 263 005e FF91      		pop r31
 264 0060 EF91      		pop r30
 265 0062 BF91      		pop r27
 266 0064 AF91      		pop r26
 267 0066 9F91      		pop r25
 268 0068 8F91      		pop r24
 269 006a 7F91      		pop r23
 270 006c 6F91      		pop r22
 271 006e 5F91      		pop r21
 272 0070 4F91      		pop r20
 273 0072 3F91      		pop r19
 274 0074 2F91      		pop r18
 275 0076 0F90      		pop r0
 276 0078 0FBE      		out __SREG__,r0
 277 007a 0F90      		pop r0
 278 007c 1F90      		pop r1
 279 007e 1895      		reti
GAS LISTING /tmp/ccNZ67a0.s 			page 23


 280               		.size	__vector_13, .-__vector_13
 281               	.Lscope4:
 282               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 283               		.stabd	78,0,0
 284               		.stabs	"__vector_14:F(0,49)",36,0,993,__vector_14
 285               	.global	__vector_14
 286               		.type	__vector_14, @function
 287               	__vector_14:
 288               		.stabd	46,0,0
 976:main.c        **** 
 977:main.c        **** //shifted right once to account for R/W bit...
 978:main.c        **** #define USI_I2C_MYEDIDADDRESS 0x50
 979:main.c        **** #define USI_I2C_MYLEDADDRESS	0x60
 980:main.c        **** 
 981:main.c        **** #define usi_i2c_isMyAddress(addr) \
 982:main.c        **** 	( ((addr) == USI_I2C_MYEDIDADDRESS)\
 983:main.c        **** 	| ((addr) == USI_I2C_MYLEDADDRESS) )
 984:main.c        **** 
 985:main.c        **** 
 986:main.c        **** // In case this device handles multiple addresses... (NYI)
 987:main.c        **** uint8_t usi_i2c_requestedAddress = 0;
 988:main.c        **** 
 989:main.c        **** uint8_t byteNum = 0;
 990:main.c        **** 
 991:main.c        **** //Basically, everything after the start-condition
 992:main.c        **** // ACK and bytes...
 993:main.c        **** ISR(USI_OVF_vect)
 994:main.c        **** {
 289               		.stabn	68,0,994,.LM21-.LFBB5
 290               	.LM21:
 291               	.LFBB5:
 292 0080 1F92      		push r1
 293 0082 0F92      		push r0
 294 0084 0FB6      		in r0,__SREG__
 295 0086 0F92      		push r0
 296 0088 1124      		clr __zero_reg__
 297 008a 2F93      		push r18
 298 008c 3F93      		push r19
 299 008e 4F93      		push r20
 300 0090 5F93      		push r21
 301 0092 6F93      		push r22
 302 0094 7F93      		push r23
 303 0096 8F93      		push r24
 304 0098 9F93      		push r25
 305 009a AF93      		push r26
 306 009c BF93      		push r27
 307 009e EF93      		push r30
 308 00a0 FF93      		push r31
 309               	/* prologue: Signal */
 310               	/* frame size = 0 */
 311               	/* stack size = 15 */
 312               	.L__stack_usage = 15
 995:main.c        **** 	//The USI counter has overflowed... this occurs in a couple cases..
 996:main.c        **** 	// First: After the address and r/w bit have been received
 997:main.c        **** 	// Second: After the ACK bit has been transmitted (by the slave)
 998:main.c        **** 	// Third: After the first data-byte has been received
 999:main.c        **** 	// Fourth: After the ACK bit has been transmitted for it...
GAS LISTING /tmp/ccNZ67a0.s 			page 24


1000:main.c        **** 	// and so on...
1001:main.c        **** 
1002:main.c        **** 	//The counter-overflow also pulls SCL Low (from the manual):
1003:main.c        **** 	// After eight bits containing slave address and data direction 
1004:main.c        **** 	// (read or write) have been transferred, the slave counter overflows 
1005:main.c        **** 	// and the SCL line is forced low. 
1006:main.c        **** 
1007:main.c        **** 	// If the slave is not the one the 
1008:main.c        **** 	// master has addressed, it releases the SCL line and waits for a new 
1009:main.c        **** 	// start condition.
1010:main.c        **** 
1011:main.c        **** 
1012:main.c        **** 	//These cases are the same as AWAITING, except if we're here,
1013:main.c        **** 	// then we're no longer awaiting them...
1014:main.c        **** 	switch(usi_i2c_state)
 313               		.stabn	68,0,1014,.LM22-.LFBB5
 314               	.LM22:
 315 00a2 8091 0000 		lds r24,usi_i2c_state
 316 00a6 8230      		cpi r24,lo8(2)
 317 00a8 01F0      		breq .L7
 318 00aa 00F4      		brsh .L8
 319 00ac 8130      		cpi r24,lo8(1)
 320 00ae 01F0      		breq .+2
 321 00b0 00C0      		rjmp .L6
 322               	.LBB13:
1015:main.c        **** 	{
1016:main.c        **** 		// The start condition interrupt occurs immediately when SDA goes low
1017:main.c        **** 		//  while SCL is high. The SCL line needs to go low once before
1018:main.c        **** 		//  data can be transmitted (this was a BITCH to find)
1019:main.c        **** 		//  in other words, there are 17 clock edges between the start-
1020:main.c        **** 		//  condition and having fully received the r/w bit
1021:main.c        **** 		case USI_STATE_START_SCL_RECEIVED:
1022:main.c        **** 	//		usi_i2c_awaitAddress();
1023:main.c        **** 			usi_i2c_state = USI_STATE_AWAITING_ADDRESS;
 323               		.stabn	68,0,1023,.LM23-.LFBB5
 324               	.LM23:
 325 00b2 82E0      		ldi r24,lo8(2)
 326 00b4 8093 0000 		sts usi_i2c_state,r24
1024:main.c        **** 
1025:main.c        **** 		   //Clear the Start-Condition flag to release SCL
1026:main.c        **** 			// ALSO the Overflow flag for the same reason
1027:main.c        **** 			// ALSO: set the counter
1028:main.c        **** 			//   16 clock edges will signal 8 bits received (address+r/w)
1029:main.c        **** 			USISR = (1<<USISIF) //Start Condition Interrupt Flag
 327               		.stabn	68,0,1029,.LM24-.LFBB5
 328               	.LM24:
 329 00b8 80EC      		ldi r24,lo8(-64)
 330 00ba 00C0      		rjmp .L53
 331               	.L8:
 332 00bc 2091 0000 		lds r18,usi_i2c_readFromSlave
 333               	.LBE13:
1014:main.c        **** 	{
 334               		.stabn	68,0,1014,.LM25-.LFBB5
 335               	.LM25:
 336 00c0 8330      		cpi r24,lo8(3)
 337 00c2 01F0      		breq .L10
 338 00c4 8430      		cpi r24,lo8(4)
GAS LISTING /tmp/ccNZ67a0.s 			page 25


 339 00c6 01F4      		brne .+2
 340 00c8 00C0      		rjmp .L11
 341 00ca 00C0      		rjmp .L6
 342               	.L7:
 343               	.LBB21:
1030:main.c        **** 										//  (ONLY cleared when written 1)
1031:main.c        **** 					| (1<<USIOIF)	//Overflow flag 
1032:main.c        **** 		         | (USICNT_MASK & 0); //Clear the USI counter
1033:main.c        **** 
1034:main.c        **** 			break;
1035:main.c        **** 		case USI_STATE_ADDRESS_RECEIVED:
1036:main.c        **** 			{};
1037:main.c        **** 
1038:main.c        **** 			byteNum = 0;
 344               		.stabn	68,0,1038,.LM26-.LFBB5
 345               	.LM26:
 346 00cc 1092 0000 		sts byteNum,__zero_reg__
1039:main.c        **** 			//heartClear();
1040:main.c        **** 			//Check to see if it's ours...
1041:main.c        **** 			uint8_t udrTemp = USIDR;
 347               		.stabn	68,0,1041,.LM27-.LFBB5
 348               	.LM27:
 349 00d0 8FB1      		in r24,0xf
1042:main.c        **** 			//1 = master-read (slave-writes to SDA)
1043:main.c        **** 			//0 = master-write (slave-reads from SDA)
1044:main.c        **** 			usi_i2c_readFromSlave = udrTemp & 0x01;
 350               		.stabn	68,0,1044,.LM28-.LFBB5
 351               	.LM28:
 352 00d2 982F      		mov r25,r24
 353 00d4 9170      		andi r25,lo8(1)
 354 00d6 9093 0000 		sts usi_i2c_readFromSlave,r25
1045:main.c        **** 			usi_i2c_requestedAddress = udrTemp >> 1;
 355               		.stabn	68,0,1045,.LM29-.LFBB5
 356               	.LM29:
 357 00da 8695      		lsr r24
 358 00dc 8093 0000 		sts usi_i2c_requestedAddress,r24
1046:main.c        **** 			
1047:main.c        **** 			//From the manual:
1048:main.c        **** 			// When the slave is addressed, it holds the SDA line low during 
1049:main.c        **** 			// the acknowledgment cycle before holding the SCL line low again
1050:main.c        **** 			if( usi_i2c_isMyAddress(usi_i2c_requestedAddress) )
 359               		.stabn	68,0,1050,.LM30-.LFBB5
 360               	.LM30:
 361 00e0 8035      		cpi r24,lo8(80)
 362 00e2 01F0      		breq .L37
 363 00e4 8036      		cpi r24,lo8(96)
 364 00e6 01F4      		brne .L50
 365               	.L37:
1051:main.c        **** 			{
1052:main.c        **** 				// Send ACK:
1053:main.c        **** 				// This is a hack:
1054:main.c        **** 				//  We get to this point on a falling-edge
1055:main.c        **** 				//  the USIDR bit 7 is loaded 0
1056:main.c        **** 				//  then the next rising edge it changes to bit 6
1057:main.c        **** 				//  the next falling edge triggers the AWAITING_ACK case below
1058:main.c        **** 				//  which releases bit 6 from the SDA pin
1059:main.c        **** 				//  The master pulls it low again for a STOP condition
GAS LISTING /tmp/ccNZ67a0.s 			page 26


1060:main.c        **** 				// It might be wiser to just set the PORT value...
1061:main.c        **** 				//USIDR = 0x3f; 
1062:main.c        **** 				USIDR = 0x00;
 366               		.stabn	68,0,1062,.LM31-.LFBB5
 367               	.LM31:
 368 00e8 1FB8      		out 0xf,__zero_reg__
1063:main.c        **** 				setoutPORT(SDA_PIN, SDAPORT);
 369               		.stabn	68,0,1063,.LM32-.LFBB5
 370               	.LM32:
 371 00ea B89A      		sbi 0x17,0
1064:main.c        **** 
1065:main.c        **** 	         usi_i2c_state = USI_STATE_AWAITING_ACK;
 372               		.stabn	68,0,1065,.LM33-.LFBB5
 373               	.LM33:
 374 00ec 83E0      		ldi r24,lo8(3)
 375 00ee 8093 0000 		sts usi_i2c_state,r24
1066:main.c        **** 
1067:main.c        **** 	         //FTM:
1068:main.c        **** 	         // (The USI Counter Register is set to 14 before releasing SCL)
1069:main.c        **** 				USI_I2C_OVERFLOW_RELEASE_SCL_AND_SET_COUNTER(14);
 376               		.stabn	68,0,1069,.LM34-.LFBB5
 377               	.LM34:
 378 00f2 8EE4      		ldi r24,lo8(78)
 379               	.L53:
 380 00f4 8EB9      		out 0xe,r24
 381 00f6 00C0      		rjmp .L12
 382               	.L50:
1070:main.c        **** 			}
1071:main.c        **** 			else //Another slave was addressed
1072:main.c        **** 				usi_i2c_awaitStart();
 383               		.stabn	68,0,1072,.LM35-.LFBB5
 384               	.LM35:
 385 00f8 00D0      		rcall usi_i2c_awaitStart
 386 00fa 00C0      		rjmp .L12
 387               	.L10:
1073:main.c        **** 
1074:main.c        **** 			break;
1075:main.c        **** 		//ACK has been transmitted from/to this device...
1076:main.c        **** 		case USI_STATE_ACK_COMPLETE:
1077:main.c        **** 			if(!usi_i2c_readFromSlave)	//slaveRead
 388               		.stabn	68,0,1077,.LM36-.LFBB5
 389               	.LM36:
 390 00fc 2111      		cpse r18,__zero_reg__
 391 00fe 00C0      		rjmp .L17
1078:main.c        **** 			{
1079:main.c        **** 				//Release SDA from the ACK (we'll be reading...)
1080:main.c        **** 				setinPORT(SDA_PIN, SDAPORT);
 392               		.stabn	68,0,1080,.LM37-.LFBB5
 393               	.LM37:
 394 0100 B898      		cbi 0x17,0
 395 0102 00C0      		rjmp .L18
 396               	.L17:
 397               	.LBB14:
1081:main.c        **** 				//Shouldn't be necessary with above, but can't hurt...
1082:main.c        **** 				//UDR = 0xff; 
1083:main.c        **** 			}
1084:main.c        **** 			else //slaveWrite
GAS LISTING /tmp/ccNZ67a0.s 			page 27


1085:main.c        **** 			{
1086:main.c        **** 				uint8_t masterACK;
1087:main.c        **** 				// First ACK will be this device's response to address+r/w
1088:main.c        **** 				// Read the master's ACK?
1089:main.c        **** 				// I guess it'd be stupid to send a read request without
1090:main.c        **** 				// actually reading a byte, but I've done it for testing...
1091:main.c        **** 				// but if that's the case, then the byteToTransmit will be 
1092:main.c        **** 				// decremented anyhow... Not sure how to handle this yet...
1093:main.c        **** 				// OTOH: if a read is requested a byte MUST be transferred
1094:main.c        **** 				// otherwise a bit-7 = 0 loaded would prevent a master-stop
1095:main.c        **** 				masterACK = !(USIDR & 0x01);
 398               		.stabn	68,0,1095,.LM38-.LFBB5
 399               	.LM38:
 400 0104 8FB1      		in r24,0xf
 401 0106 8170      		andi r24,lo8(1)
1096:main.c        **** 
1097:main.c        **** 				if(byteNum)// && !(USIDR & 0x01))
 402               		.stabn	68,0,1097,.LM39-.LFBB5
 403               	.LM39:
 404 0108 9091 0000 		lds r25,byteNum
 405 010c 9923      		tst r25
 406 010e 01F0      		breq .L19
1098:main.c        **** 				{
1099:main.c        **** 					heartBlinkInternal+= 0x10;
 407               		.stabn	68,0,1099,.LM40-.LFBB5
 408               	.LM40:
 409 0110 9091 0000 		lds r25,heartBlinkInternal
 410 0114 905F      		subi r25,lo8(-(16))
 411 0116 9093 0000 		sts heartBlinkInternal,r25
 412               	.L19:
1100:main.c        **** 					//set_heartBlink(heartBlinkInternal);
1101:main.c        **** 				}
1102:main.c        **** 
1103:main.c        **** 				//Load the byte to write to the master...
1104:main.c        **** 				//USIDR = usi_i2c_byteToTransmit;
1105:main.c        **** 
1106:main.c        **** 				//if we load the next byte and its bit7 is 0
1107:main.c        **** 				// it will hold SDA low when the master tries to 
1108:main.c        **** 				// pull it high for a stop-condition!
1109:main.c        **** 				if(masterACK)
 413               		.stabn	68,0,1109,.LM41-.LFBB5
 414               	.LM41:
 415 011a 8111      		cpse r24,__zero_reg__
 416 011c 00C0      		rjmp .L20
 417               	.LBB15:
 418               	.LBB16:
1110:main.c        **** 					USIDR = nextByteToTransmit(masterACK);
1111:main.c        **** 				else
1112:main.c        **** 					USIDR = 0xff;
1113:main.c        **** 
1114:main.c        **** 				//Decrement IF the master sent ACK...
1115:main.c        **** 				//if(masterACK)
1116:main.c        **** 				//	usi_i2c_byteToTransmit--;
1117:main.c        **** 				
1118:main.c        **** 				setoutPORT(SDA_PIN, SDAPORT);
1119:main.c        **** 			}
1120:main.c        **** 
GAS LISTING /tmp/ccNZ67a0.s 			page 28


1121:main.c        **** 			usi_i2c_state = USI_STATE_AWAITING_BYTE;
1122:main.c        **** 
1123:main.c        **** 			USI_I2C_OVERFLOW_RELEASE_SCL_AND_SET_COUNTER(0);
1124:main.c        **** 			//heartClear();
1125:main.c        **** 			break;
1126:main.c        **** 		case USI_STATE_BYTE_COMPLETE:  //BYTE transmitted/received
1127:main.c        **** 			byteNum++;
1128:main.c        **** 			// Get the byte (if receiving)
1129:main.c        **** 			if(!usi_i2c_readFromSlave)
1130:main.c        **** 			{
1131:main.c        **** 				processReceivedByte(USIDR, byteNum);
1132:main.c        **** 				//usi_i2c_receivedByte = USIDR;
1133:main.c        **** 				heartBlinkInternal = usi_i2c_receivedByte;
1134:main.c        **** 				//set_heartBlink(heartBlinkInternal);
1135:main.c        **** //				heartClear();
1136:main.c        **** 
1137:main.c        **** 				// Also, we need to send an ACK...
1138:main.c        **** 				USIDR = 0x3f;
1139:main.c        **** 				setoutPORT(SDA_PIN, SDAPORT);
1140:main.c        **** 			}
1141:main.c        **** 			else //slaveWrite
1142:main.c        **** 			{
1143:main.c        **** 				// The master sends the ACK in this case...
1144:main.c        **** 				setinPORT(SDA_PIN, SDAPORT);
1145:main.c        **** 				USIDR = 0xff;
1146:main.c        **** //				heartClear();
1147:main.c        **** 			}
1148:main.c        **** 
1149:main.c        **** 			//Reload the counter to interrupt after the ACK
1150:main.c        **** 			USI_I2C_OVERFLOW_RELEASE_SCL_AND_SET_COUNTER(14);
1151:main.c        **** 
1152:main.c        **** 			usi_i2c_state = USI_STATE_AWAITING_ACK;
1153:main.c        **** 			//heartClear();
1154:main.c        ****          break;
1155:main.c        **** 		//Shouldn't get here...
1156:main.c        **** 		default:
1157:main.c        **** 			usi_i2c_state = 0x77;
1158:main.c        **** 			//set_heartBlink(0x77);
1159:main.c        **** 			break;
1160:main.c        **** 	}
1161:main.c        **** 
1162:main.c        **** 
1163:main.c        **** 	//I want it to blink if it's not yet read the EDID...
1164:main.c        **** 	if((usi_i2c_readFromSlave)
1165:main.c        **** 		 && (usi_i2c_state == 4)
1166:main.c        **** 		 && (usi_i2c_requestedAddress == USI_I2C_MYEDIDADDRESS))
1167:main.c        **** 		set_heartBlink(0);
1168:main.c        **** 	//set_heartBlink((!(usi_i2c_readFromSlave)<<4) | usi_i2c_state);
1169:main.c        **** }
1170:main.c        **** 
1171:main.c        **** uint8_t ledsControlled = FALSE;
1172:main.c        **** 
1173:main.c        **** #define incrementEDIDIndex()	\
1174:main.c        **** {\
1175:main.c        **** 	edidArrayIndex++;\
1176:main.c        **** 	if(edidArrayIndex == EDIDARRAYLENGTH) \
1177:main.c        **** 		edidArrayIndex = 0; \
GAS LISTING /tmp/ccNZ67a0.s 			page 29


1178:main.c        **** }
1179:main.c        **** 
1180:main.c        **** #define setEDIDIndex(index) \
1181:main.c        **** {\
1182:main.c        **** 	edidArrayIndex = index;\
1183:main.c        **** 	edidArrayIndex%=EDIDARRAYLENGTH;\
1184:main.c        **** }
1185:main.c        **** 
1186:main.c        **** #define incrementLEDIndex() \
1187:main.c        **** {\
1188:main.c        **** 	ledIndex++;\
1189:main.c        **** 	if(ledIndex == 3)\
1190:main.c        **** 		ledIndex = 0;\
1191:main.c        **** }
1192:main.c        **** 
1193:main.c        **** 
1194:main.c        **** //Interesting I haven't run into this before...
1195:main.c        **** //	if(blah)
1196:main.c        **** //		setLEDIndex(blah);
1197:main.c        **** //	else
1198:main.c        **** //	{ blah }
1199:main.c        **** // APPARENTLY the semicolon causes the if statement to be closed (?)
1200:main.c        **** #define setLEDIndex(index) \
1201:main.c        **** {\
1202:main.c        **** 	ledIndex = index;\
1203:main.c        **** 	ledIndex %= 3;\
1204:main.c        **** }
1205:main.c        **** 
1206:main.c        **** void processReceivedByte(uint8_t receivedByte, uint8_t byteNum)
1207:main.c        **** {
1208:main.c        ****   if(usi_i2c_requestedAddress == USI_I2C_MYEDIDADDRESS)
1209:main.c        ****   {
1210:main.c        **** 	if(byteNum == 1)
1211:main.c        **** 	{
1212:main.c        **** 		// Could be that the EDID request doesn't send a byte-index...?
1213:main.c        **** 		//ledsControlled = FALSE;
1214:main.c        **** 		setEDIDIndex(receivedByte);
1215:main.c        **** //		edidArrayIndex = receivedByte;
1216:main.c        **** 	}
1217:main.c        **** 	else
1218:main.c        **** 	{
1219:main.c        **** 		edidArray[edidArrayIndex] = receivedByte;
1220:main.c        **** 
1221:main.c        **** 		incrementEDIDIndex();
1222:main.c        **** 		//edidArrayIndex++;
1223:main.c        **** 		//edidArrayIndex &= 0x07;
1224:main.c        **** 	}
1225:main.c        ****   }
1226:main.c        ****   else if (usi_i2c_requestedAddress == USI_I2C_MYLEDADDRESS)
1227:main.c        ****   {
1228:main.c        **** 	
1229:main.c        **** 	ledsControlled = TRUE;
1230:main.c        **** 
1231:main.c        **** 	if(byteNum == 1)
1232:main.c        **** 	{
1233:main.c        **** 		setLEDIndex(receivedByte);
1234:main.c        **** 	}
GAS LISTING /tmp/ccNZ67a0.s 			page 30


1235:main.c        **** 	else
1236:main.c        **** 	{
1237:main.c        **** 		ledState[ledIndex] = receivedByte;
1238:main.c        **** 		incrementLEDIndex();
1239:main.c        **** 	}	
1240:main.c        ****   }
1241:main.c        **** }
1242:main.c        **** 
1243:main.c        **** uint8_t nextByteToTransmit(uint8_t masterACKed)
1244:main.c        **** {
1245:main.c        **** //	static uint8_t temp = 0;
1246:main.c        **** 
1247:main.c        **** //	return temp++;
1248:main.c        **** 
1249:main.c        ****   if(usi_i2c_requestedAddress == USI_I2C_MYEDIDADDRESS)
 419               		.stabn	68,0,1249,.LM42-.LFBB5
 420               	.LM42:
 421 011e 8091 0000 		lds r24,usi_i2c_requestedAddress
 422 0122 8035      		cpi r24,lo8(80)
 423 0124 01F4      		brne .L21
 424               	.LBB17:
1250:main.c        ****   {
1251:main.c        **** 	uint8_t temp = edidArray[edidArrayIndex];
 425               		.stabn	68,0,1251,.LM43-.LFBB5
 426               	.LM43:
 427 0126 9091 0000 		lds r25,edidArrayIndex
 428 012a E92F      		mov r30,r25
 429 012c F0E0      		ldi r31,0
 430 012e E050      		subi r30,lo8(-(edidArray))
 431 0130 F040      		sbci r31,hi8(-(edidArray))
 432 0132 8081      		ld r24,Z
1252:main.c        **** 
1253:main.c        **** 	ledsControlled = FALSE;
 433               		.stabn	68,0,1253,.LM44-.LFBB5
 434               	.LM44:
 435 0134 1092 0000 		sts ledsControlled,__zero_reg__
1254:main.c        **** 	if(masterACKed)
1255:main.c        **** 	{
1256:main.c        **** 		incrementEDIDIndex();
 436               		.stabn	68,0,1256,.LM45-.LFBB5
 437               	.LM45:
 438 0138 9F5F      		subi r25,lo8(-(1))
 439 013a 9038      		cpi r25,lo8(-128)
 440 013c 01F0      		breq .L22
 441 013e 9093 0000 		sts edidArrayIndex,r25
 442 0142 00C0      		rjmp .L51
 443               	.L22:
 444 0144 1092 0000 		sts edidArrayIndex,__zero_reg__
 445 0148 00C0      		rjmp .L51
 446               	.L21:
 447               	.LBE17:
1257:main.c        **** //		edidArrayIndex++;
1258:main.c        **** 	}
1259:main.c        **** 
1260:main.c        **** //	edidArrayIndex &= 0x07;
1261:main.c        **** 
1262:main.c        **** 	return temp;
GAS LISTING /tmp/ccNZ67a0.s 			page 31


1263:main.c        ****   }
1264:main.c        ****   else if (usi_i2c_requestedAddress == USI_I2C_MYLEDADDRESS)
 448               		.stabn	68,0,1264,.LM46-.LFBB5
 449               	.LM46:
 450 014a 8036      		cpi r24,lo8(96)
 451 014c 01F4      		brne .L20
 452               	.LBB18:
1265:main.c        ****   {
1266:main.c        **** 	uint8_t temp = ledState[ledIndex];
 453               		.stabn	68,0,1266,.LM47-.LFBB5
 454               	.LM47:
 455 014e 9091 0000 		lds r25,ledIndex
 456 0152 E92F      		mov r30,r25
 457 0154 F0E0      		ldi r31,0
 458 0156 E050      		subi r30,lo8(-(ledState))
 459 0158 F040      		sbci r31,hi8(-(ledState))
 460 015a 8081      		ld r24,Z
1267:main.c        **** 
1268:main.c        **** 	if(masterACKed)
1269:main.c        **** 	{
1270:main.c        **** 		incrementLEDIndex();
 461               		.stabn	68,0,1270,.LM48-.LFBB5
 462               	.LM48:
 463 015c 9F5F      		subi r25,lo8(-(1))
 464 015e 9330      		cpi r25,lo8(3)
 465 0160 01F0      		breq .L24
 466 0162 9093 0000 		sts ledIndex,r25
 467 0166 00C0      		rjmp .L51
 468               	.L24:
 469 0168 1092 0000 		sts ledIndex,__zero_reg__
 470 016c 00C0      		rjmp .L51
 471               	.L20:
 472               	.LBE18:
 473               	.LBE16:
 474               	.LBE15:
1112:main.c        **** 
 475               		.stabn	68,0,1112,.LM49-.LFBB5
 476               	.LM49:
 477 016e 8FEF      		ldi r24,lo8(-1)
 478               	.L51:
 479 0170 8FB9      		out 0xf,r24
1118:main.c        **** 			}
 480               		.stabn	68,0,1118,.LM50-.LFBB5
 481               	.LM50:
 482 0172 B89A      		sbi 0x17,0
 483               	.L18:
 484               	.LBE14:
1121:main.c        **** 
 485               		.stabn	68,0,1121,.LM51-.LFBB5
 486               	.LM51:
 487 0174 84E0      		ldi r24,lo8(4)
 488 0176 8093 0000 		sts usi_i2c_state,r24
1123:main.c        **** 			//heartClear();
 489               		.stabn	68,0,1123,.LM52-.LFBB5
 490               	.LM52:
 491 017a 80E4      		ldi r24,lo8(64)
 492 017c 00C0      		rjmp .L53
GAS LISTING /tmp/ccNZ67a0.s 			page 32


 493               	.L11:
1127:main.c        **** 			// Get the byte (if receiving)
 494               		.stabn	68,0,1127,.LM53-.LFBB5
 495               	.LM53:
 496 017e 9091 0000 		lds r25,byteNum
 497 0182 9F5F      		subi r25,lo8(-(1))
 498 0184 9093 0000 		sts byteNum,r25
1129:main.c        **** 			{
 499               		.stabn	68,0,1129,.LM54-.LFBB5
 500               	.LM54:
 501 0188 2111      		cpse r18,__zero_reg__
 502 018a 00C0      		rjmp .L26
1131:main.c        **** 				//usi_i2c_receivedByte = USIDR;
 503               		.stabn	68,0,1131,.LM55-.LFBB5
 504               	.LM55:
 505 018c 8FB1      		in r24,0xf
 506               	.LBB19:
 507               	.LBB20:
1208:main.c        ****   {
 508               		.stabn	68,0,1208,.LM56-.LFBB5
 509               	.LM56:
 510 018e 2091 0000 		lds r18,usi_i2c_requestedAddress
 511 0192 2035      		cpi r18,lo8(80)
 512 0194 01F4      		brne .L27
1210:main.c        **** 	{
 513               		.stabn	68,0,1210,.LM57-.LFBB5
 514               	.LM57:
 515 0196 9130      		cpi r25,lo8(1)
 516 0198 01F4      		brne .L28
1214:main.c        **** //		edidArrayIndex = receivedByte;
 517               		.stabn	68,0,1214,.LM58-.LFBB5
 518               	.LM58:
 519 019a 8F77      		andi r24,lo8(127)
 520 019c 00C0      		rjmp .L52
 521               	.L28:
1219:main.c        **** 
 522               		.stabn	68,0,1219,.LM59-.LFBB5
 523               	.LM59:
 524 019e 9091 0000 		lds r25,edidArrayIndex
 525 01a2 E92F      		mov r30,r25
 526 01a4 F0E0      		ldi r31,0
 527 01a6 E050      		subi r30,lo8(-(edidArray))
 528 01a8 F040      		sbci r31,hi8(-(edidArray))
 529 01aa 8083      		st Z,r24
1221:main.c        **** 		//edidArrayIndex++;
 530               		.stabn	68,0,1221,.LM60-.LFBB5
 531               	.LM60:
 532 01ac 81E0      		ldi r24,lo8(1)
 533 01ae 890F      		add r24,r25
 534 01b0 8038      		cpi r24,lo8(-128)
 535 01b2 01F0      		breq .L30
 536               	.L52:
 537 01b4 8093 0000 		sts edidArrayIndex,r24
 538 01b8 00C0      		rjmp .L29
 539               	.L30:
 540 01ba 1092 0000 		sts edidArrayIndex,__zero_reg__
 541 01be 00C0      		rjmp .L29
GAS LISTING /tmp/ccNZ67a0.s 			page 33


 542               	.L27:
1226:main.c        ****   {
 543               		.stabn	68,0,1226,.LM61-.LFBB5
 544               	.LM61:
 545 01c0 2036      		cpi r18,lo8(96)
 546 01c2 01F4      		brne .L29
1229:main.c        **** 
 547               		.stabn	68,0,1229,.LM62-.LFBB5
 548               	.LM62:
 549 01c4 21E0      		ldi r18,lo8(1)
 550 01c6 2093 0000 		sts ledsControlled,r18
1231:main.c        **** 	{
 551               		.stabn	68,0,1231,.LM63-.LFBB5
 552               	.LM63:
 553 01ca 9130      		cpi r25,lo8(1)
 554 01cc 01F4      		brne .L32
1233:main.c        **** 	}
 555               		.stabn	68,0,1233,.LM64-.LFBB5
 556               	.LM64:
 557 01ce 63E0      		ldi r22,lo8(3)
 558 01d0 00D0      		rcall __udivmodqi4
 559 01d2 9093 0000 		sts ledIndex,r25
 560 01d6 00C0      		rjmp .L29
 561               	.L32:
1237:main.c        **** 		incrementLEDIndex();
 562               		.stabn	68,0,1237,.LM65-.LFBB5
 563               	.LM65:
 564 01d8 9091 0000 		lds r25,ledIndex
 565 01dc E92F      		mov r30,r25
 566 01de F0E0      		ldi r31,0
 567 01e0 E050      		subi r30,lo8(-(ledState))
 568 01e2 F040      		sbci r31,hi8(-(ledState))
 569 01e4 8083      		st Z,r24
1238:main.c        **** 	}	
 570               		.stabn	68,0,1238,.LM66-.LFBB5
 571               	.LM66:
 572 01e6 81E0      		ldi r24,lo8(1)
 573 01e8 890F      		add r24,r25
 574 01ea 8330      		cpi r24,lo8(3)
 575 01ec 01F0      		breq .L33
 576 01ee 8093 0000 		sts ledIndex,r24
 577 01f2 00C0      		rjmp .L29
 578               	.L33:
 579 01f4 1092 0000 		sts ledIndex,__zero_reg__
 580               	.L29:
 581               	.LBE20:
 582               	.LBE19:
1133:main.c        **** 				//set_heartBlink(heartBlinkInternal);
 583               		.stabn	68,0,1133,.LM67-.LFBB5
 584               	.LM67:
 585 01f8 8091 0000 		lds r24,usi_i2c_receivedByte
 586 01fc 8093 0000 		sts heartBlinkInternal,r24
1138:main.c        **** 				setoutPORT(SDA_PIN, SDAPORT);
 587               		.stabn	68,0,1138,.LM68-.LFBB5
 588               	.LM68:
 589 0200 8FE3      		ldi r24,lo8(63)
 590 0202 8FB9      		out 0xf,r24
GAS LISTING /tmp/ccNZ67a0.s 			page 34


1139:main.c        **** 			}
 591               		.stabn	68,0,1139,.LM69-.LFBB5
 592               	.LM69:
 593 0204 B89A      		sbi 0x17,0
 594 0206 00C0      		rjmp .L34
 595               	.L26:
1144:main.c        **** 				USIDR = 0xff;
 596               		.stabn	68,0,1144,.LM70-.LFBB5
 597               	.LM70:
 598 0208 B898      		cbi 0x17,0
1145:main.c        **** //				heartClear();
 599               		.stabn	68,0,1145,.LM71-.LFBB5
 600               	.LM71:
 601 020a 8FEF      		ldi r24,lo8(-1)
 602 020c 8FB9      		out 0xf,r24
 603               	.L34:
1150:main.c        **** 
 604               		.stabn	68,0,1150,.LM72-.LFBB5
 605               	.LM72:
 606 020e 8EE4      		ldi r24,lo8(78)
 607 0210 8EB9      		out 0xe,r24
1152:main.c        **** 			//heartClear();
 608               		.stabn	68,0,1152,.LM73-.LFBB5
 609               	.LM73:
 610 0212 83E0      		ldi r24,lo8(3)
 611 0214 00C0      		rjmp .L54
 612               	.L6:
1157:main.c        **** 			//set_heartBlink(0x77);
 613               		.stabn	68,0,1157,.LM74-.LFBB5
 614               	.LM74:
 615 0216 87E7      		ldi r24,lo8(119)
 616               	.L54:
 617 0218 8093 0000 		sts usi_i2c_state,r24
 618               	.L12:
 619               	.LBE21:
1164:main.c        **** 		 && (usi_i2c_state == 4)
 620               		.stabn	68,0,1164,.LM75-.LFBB5
 621               	.LM75:
 622 021c 8091 0000 		lds r24,usi_i2c_readFromSlave
 623 0220 8823      		tst r24
 624 0222 01F0      		breq .L5
1165:main.c        **** 		 && (usi_i2c_requestedAddress == USI_I2C_MYEDIDADDRESS))
 625               		.stabn	68,0,1165,.LM76-.LFBB5
 626               	.LM76:
 627 0224 8091 0000 		lds r24,usi_i2c_state
 628 0228 8430      		cpi r24,lo8(4)
 629 022a 01F4      		brne .L5
1166:main.c        **** 		set_heartBlink(0);
 630               		.stabn	68,0,1166,.LM77-.LFBB5
 631               	.LM77:
 632 022c 8091 0000 		lds r24,usi_i2c_requestedAddress
 633 0230 8035      		cpi r24,lo8(80)
 634 0232 01F4      		brne .L5
1167:main.c        **** 	//set_heartBlink((!(usi_i2c_readFromSlave)<<4) | usi_i2c_state);
 635               		.stabn	68,0,1167,.LM78-.LFBB5
 636               	.LM78:
 637 0234 80E0      		ldi r24,0
GAS LISTING /tmp/ccNZ67a0.s 			page 35


 638 0236 00D0      		rcall set_heartBlink
 639               	.L5:
 640               	/* epilogue start */
1169:main.c        **** 
 641               		.stabn	68,0,1169,.LM79-.LFBB5
 642               	.LM79:
 643 0238 FF91      		pop r31
 644 023a EF91      		pop r30
 645 023c BF91      		pop r27
 646 023e AF91      		pop r26
 647 0240 9F91      		pop r25
 648 0242 8F91      		pop r24
 649 0244 7F91      		pop r23
 650 0246 6F91      		pop r22
 651 0248 5F91      		pop r21
 652 024a 4F91      		pop r20
 653 024c 3F91      		pop r19
 654 024e 2F91      		pop r18
 655 0250 0F90      		pop r0
 656 0252 0FBE      		out __SREG__,r0
 657 0254 0F90      		pop r0
 658 0256 1F90      		pop r1
 659 0258 1895      		reti
 660               		.size	__vector_14, .-__vector_14
 661               		.stabs	"udrTemp:r(4,2)",64,0,1041,24
 662               		.stabn	192,0,0,.LBB13-.LFBB5
 663               		.stabs	"temp:r(4,2)",64,0,1251,24
 664               		.stabn	192,0,0,.LBB17-.LFBB5
 665               		.stabn	224,0,0,.LBE17-.LFBB5
 666               		.stabs	"temp:r(4,2)",64,0,1266,24
 667               		.stabn	192,0,0,.LBB18-.LFBB5
 668               		.stabn	224,0,0,.LBE18-.LFBB5
 669               		.stabn	224,0,0,.LBE13-.LFBB5
 670               		.stabs	"udrTemp:r(4,2)",64,0,1041,24
 671               		.stabn	192,0,0,.LBB21-.LFBB5
 672               		.stabn	224,0,0,.LBE21-.LFBB5
 673               	.Lscope5:
 674               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 675               		.stabd	78,0,0
 676               		.stabs	"edid_checkSummer:F(0,49)",36,0,1282,edid_checkSummer
 677               	.global	edid_checkSummer
 678               		.type	edid_checkSummer, @function
 679               	edid_checkSummer:
 680               		.stabd	46,0,0
1271:main.c        **** 	}
1272:main.c        **** 
1273:main.c        **** 	return temp;
1274:main.c        ****   }
1275:main.c        **** 
1276:main.c        ****   //Should only get here if we're not address
1277:main.c        ****   // in which case we shouldn't even get here.
1278:main.c        ****   return 0xff;
1279:main.c        **** }
1280:main.c        **** 
1281:main.c        **** 
1282:main.c        **** void edid_checkSummer(void)
1283:main.c        **** {
GAS LISTING /tmp/ccNZ67a0.s 			page 36


 681               		.stabn	68,0,1283,.LM80-.LFBB6
 682               	.LM80:
 683               	.LFBB6:
 684               	/* prologue: function */
 685               	/* frame size = 0 */
 686               	/* stack size = 0 */
 687               	.L__stack_usage = 0
 688 025a E0E0      		ldi r30,lo8(edidArray)
 689 025c F0E0      		ldi r31,hi8(edidArray)
1284:main.c        **** 	uint8_t i;
1285:main.c        **** 	uint8_t sum = 0;
 690               		.stabn	68,0,1285,.LM81-.LFBB6
 691               	.LM81:
 692 025e 80E0      		ldi r24,0
 693               	.L57:
1286:main.c        **** 
1287:main.c        **** 	// Don't include the garbage checksum value...
1288:main.c        **** 	// it will be overwritten here...
1289:main.c        **** 	for(i=0; i<0x7f; i++)
1290:main.c        **** 	{
1291:main.c        **** 		sum += edidArray[i];
 694               		.stabn	68,0,1291,.LM82-.LFBB6
 695               	.LM82:
 696 0260 9191      		ld r25,Z+
 697 0262 890F      		add r24,r25
1289:main.c        **** 	{
 698               		.stabn	68,0,1289,.LM83-.LFBB6
 699               	.LM83:
 700 0264 90E0      		ldi r25,hi8(edidArray+127)
 701 0266 E030      		cpi r30,lo8(edidArray+127)
 702 0268 F907      		cpc r31,r25
 703 026a 01F4      		brne .L57
1292:main.c        **** 	}
1293:main.c        **** 
1294:main.c        **** 	//Load the calculated checksum
1295:main.c        **** 	edidArray[0x7f] = (uint8_t)((uint8_t)0 - (uint8_t)(sum));
 704               		.stabn	68,0,1295,.LM84-.LFBB6
 705               	.LM84:
 706 026c 8195      		neg r24
 707 026e 8093 0000 		sts edidArray+127,r24
 708 0272 0895      		ret
 709               		.size	edid_checkSummer, .-edid_checkSummer
 710               		.stabs	"sum:r(4,2)",64,0,1285,24
 711               		.stabn	192,0,0,.LFBB6-.LFBB6
 712               		.stabn	224,0,0,.Lscope6-.LFBB6
 713               	.Lscope6:
 714               		.stabs	"",36,0,0,.Lscope6-.LFBB6
 715               		.stabd	78,0,0
 716               		.stabs	"updateLEDs:F(0,49)",36,0,1387,updateLEDs
 717               	.global	updateLEDs
 718               		.type	updateLEDs, @function
 719               	updateLEDs:
 720               		.stabd	46,0,0
1296:main.c        **** }
1297:main.c        **** 
1298:main.c        **** 
1299:main.c        **** 
GAS LISTING /tmp/ccNZ67a0.s 			page 37


1300:main.c        **** 
1301:main.c        **** #if FADER_ENABLED
1302:main.c        **** //uint8_t ledsControlled = FALSE;
1303:main.c        **** 
1304:main.c        **** #define  LED_R PB4				// D4
1305:main.c        **** #define  LED_G PB3				//	D5
1306:main.c        **** #define	LED_B HEART_PINNUM   //	D2 after trace-change PB1 //NYI
1307:main.c        **** #define LED_PORT PORTB
1308:main.c        **** 
1309:main.c        **** 
1310:main.c        **** hfm_t ledHFM[3];
1311:main.c        **** 
1312:main.c        **** 
1313:main.c        **** void updateLEDs(void);
1314:main.c        **** 
1315:main.c        **** void updateLEDFader(void)
1316:main.c        **** {
1317:main.c        **** 	static uint8_t delay=0;
1318:main.c        **** 	static theta_t theta=2; //test = 2;
1319:main.c        **** 
1320:main.c        **** 	delay++;
1321:main.c        **** 	if(delay == 0xff)
1322:main.c        **** 		theta++;
1323:main.c        **** 
1324:main.c        **** 	if(theta == SINE_PI*3)
1325:main.c        **** 		theta = 0;
1326:main.c        **** 
1327:main.c        **** 
1328:main.c        **** 
1329:main.c        **** 	if(theta < SINE_2PI)
1330:main.c        **** 		ledState[0] = \
1331:main.c        **** 			(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2) + (int16_t)127); 
1332:main.c        **** 
1333:main.c        **** 	if((theta > SINE_PI) && (theta < SINE_PI*3))
1334:main.c        **** 	  	ledState[1] = \
1335:main.c        **** 		 	(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2 - SINE_PI) 
1336:main.c        **** 				+ (int16_t)127);	  
1337:main.c        **** 
1338:main.c        **** 	if(theta > SINE_2PI)
1339:main.c        **** 		ledState[2] = \
1340:main.c        **** 			(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2 - SINE_2PI)
1341:main.c        **** 				+ (int16_t)127);
1342:main.c        **** 	else if(theta < SINE_PI)
1343:main.c        **** 		ledState[2] = \
1344:main.c        **** 			(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2 + SINE_PI) 
1345:main.c        **** 				+ (int16_t)127);
1346:main.c        **** //	ledState[1] = 0x07;
1347:main.c        **** 	
1348:main.c        **** //	ledState[2] = (uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2) + (int16_t)127);
1349:main.c        **** 
1350:main.c        **** 		//(uint32_t)(sineRaw(theta - SINE_PI_2))*127/SINE_MAX + 127;
1351:main.c        **** 
1352:main.c        **** 	/*
1353:main.c        **** 	if(theta == 0xff)
1354:main.c        **** 	{
1355:main.c        **** 		theta=0;
1356:main.c        **** 		ledState[2]++; // = test; //2; //0x07; //theta;
GAS LISTING /tmp/ccNZ67a0.s 			page 38


1357:main.c        **** 	}
1358:main.c        **** */
1359:main.c        **** //	ledState[0] = 0x07; //theta;
1360:main.c        **** 
1361:main.c        **** //	if(theta >= SINE_2PI) //*3)
1362:main.c        **** //		theta -= SINE_2PI; //*3;
1363:main.c        **** 
1364:main.c        **** //	if(theta == SINE_2PI*8)
1365:main.c        **** //	{
1366:main.c        **** //		theta = 0;
1367:main.c        **** //		togglebit(7, ledState[1]);
1368:main.c        **** //	}
1369:main.c        **** 
1370:main.c        **** //	if(theta < SINE_2PI)
1371:main.c        **** //		ledState[0] = (int32_t)theta*(int32_t)255/SINE_2PI;
1372:main.c        **** //			(((int32_t)sineRaw(theta) * (int32_t)127) / 
1373:main.c        **** //						 (int32_t)SINE_MAX) + 127;
1374:main.c        **** 		//((int8_t)(sineRaw(theta - SINE_PI_2)>>8) + (int8_t)127);
1375:main.c        **** 
1376:main.c        **** /*	if((theta > SINE_PI) && (theta < SINE_PI*3))
1377:main.c        **** 		ledState[1] = ((sineRaw(theta - SINE_PI_2 - SINE_PI)>>8) + 127);
1378:main.c        **** 
1379:main.c        **** 	if(theta > SINE_2PI)
1380:main.c        **** 		ledState[2] = ((sineRaw(theta - SINE_PI_2 - SINE_2PI)>>8) + 127);
1381:main.c        **** 	else if(theta < SINE_PI)
1382:main.c        **** 		ledState[2] = ((sineRaw(theta - SINE_PI_2 + SINE_PI)>>8) + 127);
1383:main.c        **** */
1384:main.c        **** 	updateLEDs();
1385:main.c        **** }
1386:main.c        **** 
1387:main.c        **** void updateLEDs(void)
1388:main.c        **** {
 721               		.stabn	68,0,1388,.LM85-.LFBB7
 722               	.LM85:
 723               	.LFBB7:
 724 0274 0F93      		push r16
 725 0276 1F93      		push r17
 726 0278 CF93      		push r28
 727 027a DF93      		push r29
 728               	/* prologue: function */
 729               	/* frame size = 0 */
 730               	/* stack size = 4 */
 731               	.L__stack_usage = 4
 732 027c 00E0      		ldi r16,lo8(ledHFM)
 733 027e 10E0      		ldi r17,hi8(ledHFM)
 734               		.stabn	68,0,1388,.LM86-.LFBB7
 735               	.LM86:
 736 0280 C0E0      		ldi r28,0
 737 0282 D0E0      		ldi r29,0
 738               	.L60:
1389:main.c        **** 	static uint8_t lastState[3] = {0,0,0};
1390:main.c        **** 
1391:main.c        **** 	uint8_t i;
1392:main.c        **** 	for(i=0; i<3; i++)
1393:main.c        **** 	{
1394:main.c        **** 	//	if(ledState[i] != lastState[i])
1395:main.c        **** 		{
GAS LISTING /tmp/ccNZ67a0.s 			page 39


1396:main.c        **** 		//	ledsControlled = TRUE;
1397:main.c        **** 			lastState[i] = ledState[i];
 739               		.stabn	68,0,1397,.LM87-.LFBB7
 740               	.LM87:
 741 0284 FE01      		movw r30,r28
 742 0286 E050      		subi r30,lo8(-(ledState))
 743 0288 F040      		sbci r31,hi8(-(ledState))
 744 028a 8081      		ld r24,Z
1398:main.c        **** 			hfm_setPower(&(ledHFM[i]), ledState[i]);
 745               		.stabn	68,0,1398,.LM88-.LFBB7
 746               	.LM88:
 747 028c 6081      		ld r22,Z
 748 028e C801      		movw r24,r16
 749 0290 00D0      		rcall hfm_setPower
 750 0292 2196      		adiw r28,1
 751 0294 0C5F      		subi r16,-4
 752 0296 1F4F      		sbci r17,-1
1392:main.c        **** 	{
 753               		.stabn	68,0,1392,.LM89-.LFBB7
 754               	.LM89:
 755 0298 C330      		cpi r28,3
 756 029a D105      		cpc r29,__zero_reg__
 757 029c 01F4      		brne .L60
1399:main.c        **** 		}
1400:main.c        **** 	}
1401:main.c        **** 	//hfm_setPower(&led_r, ledState[0]);
1402:main.c        **** 	//hfm_setPower(&led_g, ledState[1]);
1403:main.c        **** 
1404:main.c        **** 
1405:main.c        **** 	if(hfm_nextOutput(&(ledHFM[0])))
 758               		.stabn	68,0,1405,.LM90-.LFBB7
 759               	.LM90:
 760 029e 80E0      		ldi r24,lo8(ledHFM)
 761 02a0 90E0      		ldi r25,hi8(ledHFM)
 762 02a2 00D0      		rcall hfm_nextOutput
 763 02a4 8823      		tst r24
 764 02a6 01F0      		breq .L61
1406:main.c        **** 		clrpinPORT(LED_R, LED_PORT);
 765               		.stabn	68,0,1406,.LM91-.LFBB7
 766               	.LM91:
 767 02a8 C498      		cbi 0x18,4
 768 02aa 00C0      		rjmp .L62
 769               	.L61:
1407:main.c        **** 	else
1408:main.c        **** 		setpinPORT(LED_R, LED_PORT);
 770               		.stabn	68,0,1408,.LM92-.LFBB7
 771               	.LM92:
 772 02ac C49A      		sbi 0x18,4
 773               	.L62:
1409:main.c        **** 
1410:main.c        **** 	if(hfm_nextOutput(&(ledHFM[1])))
 774               		.stabn	68,0,1410,.LM93-.LFBB7
 775               	.LM93:
 776 02ae 80E0      		ldi r24,lo8(ledHFM+4)
 777 02b0 90E0      		ldi r25,hi8(ledHFM+4)
 778 02b2 00D0      		rcall hfm_nextOutput
 779 02b4 8823      		tst r24
GAS LISTING /tmp/ccNZ67a0.s 			page 40


 780 02b6 01F0      		breq .L63
1411:main.c        **** 		clrpinPORT(LED_G, LED_PORT);
 781               		.stabn	68,0,1411,.LM94-.LFBB7
 782               	.LM94:
 783 02b8 C398      		cbi 0x18,3
 784 02ba 00C0      		rjmp .L64
 785               	.L63:
1412:main.c        **** 	else
1413:main.c        **** 		setpinPORT(LED_G, LED_PORT);
 786               		.stabn	68,0,1413,.LM95-.LFBB7
 787               	.LM95:
 788 02bc C39A      		sbi 0x18,3
 789               	.L64:
1414:main.c        **** 
1415:main.c        **** 	if(hfm_nextOutput(&(ledHFM[2])))
 790               		.stabn	68,0,1415,.LM96-.LFBB7
 791               	.LM96:
 792 02be 80E0      		ldi r24,lo8(ledHFM+8)
 793 02c0 90E0      		ldi r25,hi8(ledHFM+8)
 794 02c2 00D0      		rcall hfm_nextOutput
 795 02c4 8823      		tst r24
 796 02c6 01F0      		breq .L65
1416:main.c        **** 		clrpinPORT(LED_B, LED_PORT);
 797               		.stabn	68,0,1416,.LM97-.LFBB7
 798               	.LM97:
 799 02c8 C198      		cbi 0x18,1
 800 02ca 00C0      		rjmp .L59
 801               	.L65:
1417:main.c        **** 	else
1418:main.c        **** 		setpinPORT(LED_B, LED_PORT);
 802               		.stabn	68,0,1418,.LM98-.LFBB7
 803               	.LM98:
 804 02cc C19A      		sbi 0x18,1
 805               	.L59:
 806               	/* epilogue start */
1419:main.c        **** 
1420:main.c        **** 	//NYI:
1421:main.c        **** 	//if(ledState[2])
1422:main.c        **** 
1423:main.c        **** //	togglepinPORT(LED_R, LED_PORT);
1424:main.c        **** //	togglepinPORT(LED_G, LED_PORT);
1425:main.c        **** }
 807               		.stabn	68,0,1425,.LM99-.LFBB7
 808               	.LM99:
 809 02ce DF91      		pop r29
 810 02d0 CF91      		pop r28
 811 02d2 1F91      		pop r17
 812 02d4 0F91      		pop r16
 813 02d6 0895      		ret
 814               		.size	updateLEDs, .-updateLEDs
 815               	.Lscope7:
 816               		.stabs	"",36,0,0,.Lscope7-.LFBB7
 817               		.stabd	78,0,0
 818               		.stabs	"updateLEDFader:F(0,49)",36,0,1315,updateLEDFader
 819               	.global	updateLEDFader
 820               		.type	updateLEDFader, @function
 821               	updateLEDFader:
GAS LISTING /tmp/ccNZ67a0.s 			page 41


 822               		.stabd	46,0,0
1316:main.c        **** 	static uint8_t delay=0;
 823               		.stabn	68,0,1316,.LM100-.LFBB8
 824               	.LM100:
 825               	.LFBB8:
 826               	/* prologue: function */
 827               	/* frame size = 0 */
 828               	/* stack size = 0 */
 829               	.L__stack_usage = 0
1320:main.c        **** 	if(delay == 0xff)
 830               		.stabn	68,0,1320,.LM101-.LFBB8
 831               	.LM101:
 832 02d8 8091 0000 		lds r24,delay.1929
 833 02dc 8F5F      		subi r24,lo8(-(1))
 834 02de 8093 0000 		sts delay.1929,r24
1321:main.c        **** 		theta++;
 835               		.stabn	68,0,1321,.LM102-.LFBB8
 836               	.LM102:
 837 02e2 8F3F      		cpi r24,lo8(-1)
 838 02e4 01F4      		brne .L69
1322:main.c        **** 
 839               		.stabn	68,0,1322,.LM103-.LFBB8
 840               	.LM103:
 841 02e6 8091 0000 		lds r24,theta.1930
 842 02ea 9091 0000 		lds r25,theta.1930+1
 843 02ee 0196      		adiw r24,1
 844 02f0 9093 0000 		sts theta.1930+1,r25
 845 02f4 8093 0000 		sts theta.1930,r24
 846               	.L69:
1324:main.c        **** 		theta = 0;
 847               		.stabn	68,0,1324,.LM104-.LFBB8
 848               	.LM104:
 849 02f8 8091 0000 		lds r24,theta.1930
 850 02fc 9091 0000 		lds r25,theta.1930+1
 851 0300 8115      		cp r24,__zero_reg__
 852 0302 9340      		sbci r25,3
 853 0304 01F4      		brne .L70
1325:main.c        **** 
 854               		.stabn	68,0,1325,.LM105-.LFBB8
 855               	.LM105:
 856 0306 1092 0000 		sts theta.1930+1,__zero_reg__
 857 030a 1092 0000 		sts theta.1930,__zero_reg__
 858               	.L70:
1329:main.c        **** 		ledState[0] = \
 859               		.stabn	68,0,1329,.LM106-.LFBB8
 860               	.LM106:
 861 030e 8091 0000 		lds r24,theta.1930
 862 0312 9091 0000 		lds r25,theta.1930+1
 863 0316 8115      		cp r24,__zero_reg__
 864 0318 42E0      		ldi r20,2
 865 031a 9407      		cpc r25,r20
 866 031c 04F4      		brge .L71
1331:main.c        **** 
 867               		.stabn	68,0,1331,.LM107-.LFBB8
 868               	.LM107:
 869 031e 8058      		subi r24,-128
 870 0320 9109      		sbc r25,__zero_reg__
GAS LISTING /tmp/ccNZ67a0.s 			page 42


 871 0322 00D0      		rcall sineRaw8
 872 0324 8158      		subi r24,lo8(-(127))
1330:main.c        **** 			(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2) + (int16_t)127); 
 873               		.stabn	68,0,1330,.LM108-.LFBB8
 874               	.LM108:
 875 0326 8093 0000 		sts ledState,r24
 876               	.L71:
1333:main.c        **** 	  	ledState[1] = \
 877               		.stabn	68,0,1333,.LM109-.LFBB8
 878               	.LM109:
 879 032a 8091 0000 		lds r24,theta.1930
 880 032e 9091 0000 		lds r25,theta.1930+1
 881 0332 9C01      		movw r18,r24
 882 0334 2150      		subi r18,1
 883 0336 3140      		sbci r19,1
 884 0338 2F3F      		cpi r18,-1
 885 033a 3140      		sbci r19,1
 886 033c 00F4      		brsh .L72
1335:main.c        **** 				+ (int16_t)127);	  
 887               		.stabn	68,0,1335,.LM110-.LFBB8
 888               	.LM110:
 889 033e 8058      		subi r24,-128
 890 0340 9140      		sbci r25,1
 891 0342 00D0      		rcall sineRaw8
 892 0344 8158      		subi r24,lo8(-(127))
1334:main.c        **** 		 	(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2 - SINE_PI) 
 893               		.stabn	68,0,1334,.LM111-.LFBB8
 894               	.LM111:
 895 0346 8093 0000 		sts ledState+1,r24
 896               	.L72:
1338:main.c        **** 		ledState[2] = \
 897               		.stabn	68,0,1338,.LM112-.LFBB8
 898               	.LM112:
 899 034a 8091 0000 		lds r24,theta.1930
 900 034e 9091 0000 		lds r25,theta.1930+1
 901 0352 8130      		cpi r24,1
 902 0354 22E0      		ldi r18,2
 903 0356 9207      		cpc r25,r18
 904 0358 04F0      		brlt .L73
1340:main.c        **** 				+ (int16_t)127);
 905               		.stabn	68,0,1340,.LM113-.LFBB8
 906               	.LM113:
 907 035a 8058      		subi r24,-128
 908 035c 9240      		sbci r25,2
 909 035e 00C0      		rjmp .L75
 910               	.L73:
1342:main.c        **** 		ledState[2] = \
 911               		.stabn	68,0,1342,.LM114-.LFBB8
 912               	.LM114:
 913 0360 8F3F      		cpi r24,-1
 914 0362 9105      		cpc r25,__zero_reg__
 915 0364 01F0      		breq .+2
 916 0366 04F4      		brge .L74
1344:main.c        **** 				+ (int16_t)127);
 917               		.stabn	68,0,1344,.LM115-.LFBB8
 918               	.LM115:
 919 0368 8058      		subi r24,-128
GAS LISTING /tmp/ccNZ67a0.s 			page 43


 920 036a 9F4F      		sbci r25,-1
 921               	.L75:
 922 036c 00D0      		rcall sineRaw8
 923 036e 8158      		subi r24,lo8(-(127))
1343:main.c        **** 			(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2 + SINE_PI) 
 924               		.stabn	68,0,1343,.LM116-.LFBB8
 925               	.LM116:
 926 0370 8093 0000 		sts ledState+2,r24
 927               	.L74:
1384:main.c        **** }
 928               		.stabn	68,0,1384,.LM117-.LFBB8
 929               	.LM117:
 930 0374 00C0      		rjmp updateLEDs
 931               		.size	updateLEDFader, .-updateLEDFader
 932               		.stabs	"delay:V(4,2)",38,0,1317,delay.1929
 933               		.stabs	"theta:V(11,1)",38,0,1318,theta.1930
 934               		.stabn	192,0,0,.LFBB8-.LFBB8
 935               		.stabn	224,0,0,.Lscope8-.LFBB8
 936               	.Lscope8:
 937               		.stabs	"",36,0,0,.Lscope8-.LFBB8
 938               		.stabd	78,0,0
 939               		.section	.text.startup,"ax",@progbits
 940               		.stabs	"main:F(0,1)",36,0,1428,main
 941               	.global	main
 942               		.type	main, @function
 943               	main:
 944               		.stabd	46,0,0
1426:main.c        **** #endif
1427:main.c        **** 
1428:main.c        **** int main(void)
1429:main.c        **** {
 945               		.stabn	68,0,1429,.LM118-.LFBB9
 946               	.LM118:
 947               	.LFBB9:
 948               	/* prologue: function */
 949               	/* frame size = 0 */
 950               	/* stack size = 0 */
 951               	.L__stack_usage = 0
 952 0000 C0E0      		ldi r28,lo8(ledHFM)
 953 0002 D0E0      		ldi r29,hi8(ledHFM)
 954               	.L77:
1430:main.c        **** #if FADER_ENABLED
1431:main.c        **** 	uint8_t i;
1432:main.c        **** 	for(i=0; i<3; i++)
1433:main.c        **** 		hfm_setup(&(ledHFM[i]), 0, 255);
 955               		.stabn	68,0,1433,.LM119-.LFBB9
 956               	.LM119:
 957 0004 4FEF      		ldi r20,lo8(-1)
 958 0006 60E0      		ldi r22,0
 959 0008 CE01      		movw r24,r28
 960 000a 00D0      		rcall hfm_setup
 961 000c 2496      		adiw r28,4
1432:main.c        **** 		hfm_setup(&(ledHFM[i]), 0, 255);
 962               		.stabn	68,0,1432,.LM120-.LFBB9
 963               	.LM120:
 964 000e 80E0      		ldi r24,hi8(ledHFM+12)
 965 0010 C030      		cpi r28,lo8(ledHFM+12)
GAS LISTING /tmp/ccNZ67a0.s 			page 44


 966 0012 D807      		cpc r29,r24
 967 0014 01F4      		brne .L77
1434:main.c        **** 	//hfm_setup(&led_g, 0, 255);
1435:main.c        **** #endif
1436:main.c        **** 
1437:main.c        **** //	uint16_t i;
1438:main.c        **** //	for(i=0; i<256; i++)
1439:main.c        **** //		edidArray[i] = i;
1440:main.c        **** 
1441:main.c        **** 	//Found experimentally: assuming the free-running ADC is always 13
1442:main.c        **** 	// cycles per interrupt...
1443:main.c        **** 	// The default value was read to be 0x9f
1444:main.c        **** 	// This is of course device-specific
1445:main.c        **** //	OSCCAL = 0x9a;
1446:main.c        **** 
1447:main.c        **** 	//*** Initializations ***
1448:main.c        **** 
1449:main.c        **** 	//!!! WDT could cause problems... this probably should be inited earlier and called everywhere...
1450:main.c        **** 	//INIT_HEARTBEAT(HEARTBEATPIN, HEARTBEAT, HEARTCONNECTION);
1451:main.c        **** 
1452:main.c        **** 
1453:main.c        **** 	init_heartBeat();
 968               		.stabn	68,0,1453,.LM121-.LFBB9
 969               	.LM121:
 970 0016 00D0      		rcall init_heartBeat
1454:main.c        **** 
1455:main.c        **** 	setHeartRate(0);	
 971               		.stabn	68,0,1455,.LM122-.LFBB9
 972               	.LM122:
 973 0018 80E0      		ldi r24,0
 974 001a 00D0      		rcall setHeartRate
1456:main.c        **** 
1457:main.c        **** 	//Blink until the EDID is read...
1458:main.c        **** 	//This is hokey...
1459:main.c        **** 	//set_heartBlink(1);
1460:main.c        **** 
1461:main.c        **** 	edid_checkSummer();
 975               		.stabn	68,0,1461,.LM123-.LFBB9
 976               	.LM123:
 977 001c 00D0      		rcall edid_checkSummer
 978               	.LBB22:
 979               	.LBB23:
 927:main.c        **** }
 980               		.stabn	68,0,927,.LM124-.LFBB9
 981               	.LM124:
 982 001e 00D0      		rcall usi_i2c_awaitStart
 983               	.LBE23:
 984               	.LBE22:
1462:main.c        **** 
1463:main.c        **** 	usi_i2c_slaveInit();
1464:main.c        **** 
1465:main.c        **** #if FADER_ENABLED
1466:main.c        **** 	setoutPORT(LED_R, LED_PORT);
 985               		.stabn	68,0,1466,.LM125-.LFBB9
 986               	.LM125:
 987 0020 BC9A      		sbi 0x17,4
1467:main.c        **** 	setoutPORT(LED_G, LED_PORT);
GAS LISTING /tmp/ccNZ67a0.s 			page 45


 988               		.stabn	68,0,1467,.LM126-.LFBB9
 989               	.LM126:
 990 0022 BB9A      		sbi 0x17,3
1468:main.c        **** 	setpinPORT(LED_R, LED_PORT);
 991               		.stabn	68,0,1468,.LM127-.LFBB9
 992               	.LM127:
 993 0024 C49A      		sbi 0x18,4
1469:main.c        **** 	setpinPORT(LED_G, LED_PORT);
 994               		.stabn	68,0,1469,.LM128-.LFBB9
 995               	.LM128:
 996 0026 C39A      		sbi 0x18,3
 997               	.L78:
1470:main.c        **** #endif
1471:main.c        **** 
1472:main.c        **** //	setoutPORT(LED_B, LED_PORT);
1473:main.c        **** 
1474:main.c        **** 	//This was only necessary for debugging timer initialization bugs...
1475:main.c        **** 	// which have been resolved
1476:main.c        **** //	set_heartBlink(retVal);
1477:main.c        **** 
1478:main.c        **** 	while(1)
1479:main.c        **** 	{
1480:main.c        **** #if FADER_ENABLED
1481:main.c        **** 		if(!ledsControlled)
 998               		.stabn	68,0,1481,.LM129-.LFBB9
 999               	.LM129:
 1000 0028 8091 0000 		lds r24,ledsControlled
 1001 002c 8111      		cpse r24,__zero_reg__
 1002 002e 00C0      		rjmp .L79
 1003               	.LBB24:
1482:main.c        **** 		{
1483:main.c        **** 			extern uint8_t heartBlink; 
1484:main.c        **** 
1485:main.c        **** 			if(heartBlink)
 1004               		.stabn	68,0,1485,.LM130-.LFBB9
 1005               	.LM130:
 1006 0030 8091 0000 		lds r24,heartBlink
 1007 0034 8823      		tst r24
 1008 0036 01F0      		breq .L80
1486:main.c        **** 				heartUpdate();
 1009               		.stabn	68,0,1486,.LM131-.LFBB9
 1010               	.LM131:
 1011 0038 00D0      		rcall heartUpdate
 1012 003a 00C0      		rjmp .L78
 1013               	.L80:
1487:main.c        **** 			else
1488:main.c        **** 				updateLEDFader();
 1014               		.stabn	68,0,1488,.LM132-.LFBB9
 1015               	.LM132:
 1016 003c 00D0      		rcall updateLEDFader
 1017 003e 00C0      		rjmp .L78
 1018               	.L79:
 1019               	.LBE24:
1489:main.c        **** 		}
1490:main.c        **** 		//This was not previously elsed... how did the heart work at all?!
1491:main.c        **** 		// at one point it didn't (and neither did updateLEDs()
1492:main.c        **** 		// but somehow it started up again
GAS LISTING /tmp/ccNZ67a0.s 			page 46


1493:main.c        **** 		// a/o v49: May have been a result of the hfm bug...
1494:main.c        **** 		// 			(how did it start up again? Something to do with an
1495:main.c        **** 		//           uninitialized value in HFM?)
1496:main.c        **** 		else
1497:main.c        **** 		{
1498:main.c        **** 			// The heartbeat may have been in input (off) mode when switched
1499:main.c        **** 			setoutPORT(LED_B, LED_PORT);
 1020               		.stabn	68,0,1499,.LM133-.LFBB9
 1021               	.LM133:
 1022 0040 B99A      		sbi 0x17,1
1500:main.c        **** 
1501:main.c        **** 			updateLEDs();
 1023               		.stabn	68,0,1501,.LM134-.LFBB9
 1024               	.LM134:
 1025 0042 00D0      		rcall updateLEDs
 1026 0044 00C0      		rjmp .L78
 1027               		.size	main, .-main
 1028               	.Lscope9:
 1029               		.stabs	"",36,0,0,.Lscope9-.LFBB9
 1030               		.stabd	78,0,0
 1031               		.data
 1032               		.type	theta.1930, @object
 1033               		.size	theta.1930, 2
 1034               	theta.1930:
 1035 0000 0200      		.word	2
 1036               		.local	delay.1929
 1037               		.comm	delay.1929,1,1
 1038               		.comm	ledHFM,12,1
 1039               	.global	ledsControlled
 1040               		.section .bss
 1041               		.type	ledsControlled, @object
 1042               		.size	ledsControlled, 1
 1043               	ledsControlled:
 1044 0000 00        		.zero	1
 1045               	.global	byteNum
 1046               		.type	byteNum, @object
 1047               		.size	byteNum, 1
 1048               	byteNum:
 1049 0001 00        		.zero	1
 1050               	.global	usi_i2c_requestedAddress
 1051               		.type	usi_i2c_requestedAddress, @object
 1052               		.size	usi_i2c_requestedAddress, 1
 1053               	usi_i2c_requestedAddress:
 1054 0002 00        		.zero	1
 1055               	.global	heartBlinkInternal
 1056               		.type	heartBlinkInternal, @object
 1057               		.size	heartBlinkInternal, 1
 1058               	heartBlinkInternal:
 1059 0003 00        		.zero	1
 1060               	.global	usi_i2c_receivedByte
 1061               		.type	usi_i2c_receivedByte, @object
 1062               		.size	usi_i2c_receivedByte, 1
 1063               	usi_i2c_receivedByte:
 1064 0004 00        		.zero	1
 1065               	.global	usi_i2c_requestedAddres
 1066               		.type	usi_i2c_requestedAddres, @object
 1067               		.size	usi_i2c_requestedAddres, 1
GAS LISTING /tmp/ccNZ67a0.s 			page 47


 1068               	usi_i2c_requestedAddres:
 1069 0005 00        		.zero	1
 1070               	.global	usi_i2c_readFromSlave
 1071               		.type	usi_i2c_readFromSlave, @object
 1072               		.size	usi_i2c_readFromSlave, 1
 1073               	usi_i2c_readFromSlave:
 1074 0006 00        		.zero	1
 1075               	.global	usi_i2c_state
 1076               		.type	usi_i2c_state, @object
 1077               		.size	usi_i2c_state, 1
 1078               	usi_i2c_state:
 1079 0007 00        		.zero	1
 1080               	.global	usi_i2c_byteToTransmit
 1081               		.data
 1082               		.type	usi_i2c_byteToTransmit, @object
 1083               		.size	usi_i2c_byteToTransmit, 1
 1084               	usi_i2c_byteToTransmit:
 1085 0002 FF        		.byte	-1
 1086               	.global	edidArrayIndex
 1087               		.section .bss
 1088               		.type	edidArrayIndex, @object
 1089               		.size	edidArrayIndex, 1
 1090               	edidArrayIndex:
 1091 0008 00        		.zero	1
 1092               	.global	edidArray
 1093               		.data
 1094               		.type	edidArray, @object
 1095               		.size	edidArray, 128
 1096               	edidArray:
 1097 0003 00        		.byte	0
 1098 0004 FF        		.byte	-1
 1099 0005 FF        		.byte	-1
 1100 0006 FF        		.byte	-1
 1101 0007 FF        		.byte	-1
 1102 0008 FF        		.byte	-1
 1103 0009 FF        		.byte	-1
 1104 000a 00        		.byte	0
 1105 000b 34        		.byte	52
 1106 000c A8        		.byte	-88
 1107 000d 66        		.byte	102
 1108 000e 01        		.byte	1
 1109 000f 00        		.byte	0
 1110 0010 00        		.byte	0
 1111 0011 00        		.byte	0
 1112 0012 00        		.byte	0
 1113 0013 00        		.byte	0
 1114 0014 1C        		.byte	28
 1115 0015 01        		.byte	1
 1116 0016 03        		.byte	3
 1117 0017 80        		.byte	-128
 1118 0018 19        		.byte	25
 1119 0019 12        		.byte	18
 1120 001a 78        		.byte	120
 1121 001b 0A        		.byte	10
 1122 001c AF        		.byte	-81
 1123 001d 40        		.byte	64
 1124 001e 95        		.byte	-107
GAS LISTING /tmp/ccNZ67a0.s 			page 48


 1125 001f 56        		.byte	86
 1126 0020 4A        		.byte	74
 1127 0021 8F        		.byte	-113
 1128 0022 25        		.byte	37
 1129 0023 20        		.byte	32
 1130 0024 50        		.byte	80
 1131 0025 54        		.byte	84
 1132 0026 00        		.byte	0
 1133 0027 00        		.byte	0
 1134 0028 00        		.byte	0
 1135 0029 01        		.byte	1
 1136 002a 01        		.byte	1
 1137 002b 01        		.byte	1
 1138 002c 01        		.byte	1
 1139 002d 01        		.byte	1
 1140 002e 01        		.byte	1
 1141 002f 01        		.byte	1
 1142 0030 01        		.byte	1
 1143 0031 01        		.byte	1
 1144 0032 01        		.byte	1
 1145 0033 01        		.byte	1
 1146 0034 01        		.byte	1
 1147 0035 01        		.byte	1
 1148 0036 01        		.byte	1
 1149 0037 01        		.byte	1
 1150 0038 01        		.byte	1
 1151 0039 D0        		.byte	-48
 1152 003a 20        		.byte	32
 1153 003b 00        		.byte	0
 1154 003c 80        		.byte	-128
 1155 003d 50        		.byte	80
 1156 003e 20        		.byte	32
 1157 003f 27        		.byte	39
 1158 0040 30        		.byte	48
 1159 0041 20        		.byte	32
 1160 0042 40        		.byte	64
 1161 0043 F8        		.byte	-8
 1162 0044 00        		.byte	0
 1163 0045 F5        		.byte	-11
 1164 0046 B8        		.byte	-72
 1165 0047 00        		.byte	0
 1166 0048 00        		.byte	0
 1167 0049 00        		.byte	0
 1168 004a 18        		.byte	24
 1169 004b 00        		.byte	0
 1170 004c 00        		.byte	0
 1171 004d 00        		.byte	0
 1172 004e 10        		.byte	16
 1173 004f 00        		.byte	0
 1174 0050 00        		.byte	0
 1175 0051 00        		.byte	0
 1176 0052 00        		.byte	0
 1177 0053 00        		.byte	0
 1178 0054 00        		.byte	0
 1179 0055 00        		.byte	0
 1180 0056 00        		.byte	0
 1181 0057 00        		.byte	0
GAS LISTING /tmp/ccNZ67a0.s 			page 49


 1182 0058 00        		.byte	0
 1183 0059 00        		.byte	0
 1184 005a 00        		.byte	0
 1185 005b 00        		.byte	0
 1186 005c 00        		.byte	0
 1187 005d 00        		.byte	0
 1188 005e 00        		.byte	0
 1189 005f 00        		.byte	0
 1190 0060 10        		.byte	16
 1191 0061 00        		.byte	0
 1192 0062 00        		.byte	0
 1193 0063 00        		.byte	0
 1194 0064 00        		.byte	0
 1195 0065 00        		.byte	0
 1196 0066 00        		.byte	0
 1197 0067 00        		.byte	0
 1198 0068 00        		.byte	0
 1199 0069 00        		.byte	0
 1200 006a 00        		.byte	0
 1201 006b 00        		.byte	0
 1202 006c 00        		.byte	0
 1203 006d 00        		.byte	0
 1204 006e 00        		.byte	0
 1205 006f 00        		.byte	0
 1206 0070 00        		.byte	0
 1207 0071 00        		.byte	0
 1208 0072 FC        		.byte	-4
 1209 0073 00        		.byte	0
 1210 0074 6D        		.byte	109
 1211 0075 65        		.byte	101
 1212 0076 68        		.byte	104
 1213 0077 4C        		.byte	76
 1214 0078 54        		.byte	84
 1215 0079 44        		.byte	68
 1216 007a 31        		.byte	49
 1217 007b 32        		.byte	50
 1218 007c 31        		.byte	49
 1219 007d 4B        		.byte	75
 1220 007e 4D        		.byte	77
 1221 007f 37        		.byte	55
 1222 0080 4B        		.byte	75
 1223 0081 00        		.byte	0
 1224 0082 75        		.byte	117
 1225               	.global	ledIndex
 1226               		.section .bss
 1227               		.type	ledIndex, @object
 1228               		.size	ledIndex, 1
 1229               	ledIndex:
 1230 0009 00        		.zero	1
 1231               	.global	ledState
 1232               		.type	ledState, @object
 1233               		.size	ledState, 3
 1234               	ledState:
 1235 000a 0000 00   		.zero	3
 1236               	.global	header
 1237               		.section	.progmem.data,"a",@progbits
 1238               		.type	header, @object
GAS LISTING /tmp/ccNZ67a0.s 			page 50


 1239               		.size	header, 32
 1240               	header:
 1241 0000 4C43 4472 		.string	"LCDreIDer66 2018-05-25 01:30:52"
 1241      6549 4465 
 1241      7236 3620 
 1241      3230 3138 
 1241      2D30 352D 
 1242               		.stabs	"header:G(0,50)=ar(0,51)=r(0,51);0;0177777;;0;31;(0,52)=k(4,2)",32,0,16,0
 1243               		.stabs	"ledState:G(0,53)=ar(0,51);0;2;(0,54)=B(4,2)",32,0,289,0
 1244               		.stabs	"ledIndex:G(4,2)",32,0,290,0
 1245               		.stabs	"edidArray:G(0,55)=ar(0,51);0;127;(4,2)",32,0,298,0
 1246               		.stabs	"edidArrayIndex:G(4,2)",32,0,788,0
 1247               		.stabs	"usi_i2c_byteToTransmit:G(4,2)",32,0,820,0
 1248               		.stabs	"usi_i2c_state:G(4,2)",32,0,821,0
 1249               		.stabs	"usi_i2c_readFromSlave:G(4,2)",32,0,822,0
 1250               		.stabs	"usi_i2c_requestedAddres:G(4,2)",32,0,823,0
 1251               		.stabs	"usi_i2c_receivedByte:G(4,2)",32,0,824,0
 1252               		.stabs	"heartBlinkInternal:G(4,2)",32,0,930,0
 1253               		.stabs	"usi_i2c_requestedAddress:G(4,2)",32,0,987,0
 1254               		.stabs	"byteNum:G(4,2)",32,0,989,0
 1255               		.stabs	"ledsControlled:G(4,2)",32,0,1171,0
 1256               		.stabs	"ledHFM:G(0,56)=ar(0,51);0;2;(9,1)",32,0,1310,0
 1257               		.text
 1258               		.stabs	"",100,0,0,.Letext0
 1259               	.Letext0:
 1260               		.ident	"GCC: (GNU) 5.4.0"
 1261               	.global __do_copy_data
 1262               	.global __do_clear_bss
GAS LISTING /tmp/ccNZ67a0.s 			page 51


DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccNZ67a0.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccNZ67a0.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccNZ67a0.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccNZ67a0.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccNZ67a0.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccNZ67a0.s:128    .text:0000000000000000 usi_i2c_awaitStart
     /tmp/ccNZ67a0.s:1078   .bss:0000000000000007 usi_i2c_state
     /tmp/ccNZ67a0.s:168    .text:0000000000000016 usi_i2c_awaitStartSCL
     /tmp/ccNZ67a0.s:201    .text:000000000000002a usi_i2c_slaveInit
     /tmp/ccNZ67a0.s:220    .text:000000000000002c __vector_13
     /tmp/ccNZ67a0.s:1058   .bss:0000000000000003 heartBlinkInternal
     /tmp/ccNZ67a0.s:287    .text:0000000000000080 __vector_14
     /tmp/ccNZ67a0.s:1073   .bss:0000000000000006 usi_i2c_readFromSlave
     /tmp/ccNZ67a0.s:1048   .bss:0000000000000001 byteNum
     /tmp/ccNZ67a0.s:1053   .bss:0000000000000002 usi_i2c_requestedAddress
     /tmp/ccNZ67a0.s:1090   .bss:0000000000000008 edidArrayIndex
     /tmp/ccNZ67a0.s:1096   .data:0000000000000003 edidArray
     /tmp/ccNZ67a0.s:1043   .bss:0000000000000000 ledsControlled
     /tmp/ccNZ67a0.s:1229   .bss:0000000000000009 ledIndex
     /tmp/ccNZ67a0.s:1234   .bss:000000000000000a ledState
     /tmp/ccNZ67a0.s:1063   .bss:0000000000000004 usi_i2c_receivedByte
     /tmp/ccNZ67a0.s:679    .text:000000000000025a edid_checkSummer
     /tmp/ccNZ67a0.s:719    .text:0000000000000274 updateLEDs
                            *COM*:000000000000000c ledHFM
     /tmp/ccNZ67a0.s:821    .text:00000000000002d8 updateLEDFader
                             .bss:000000000000000d delay.1929
     /tmp/ccNZ67a0.s:1034   .data:0000000000000000 theta.1930
     /tmp/ccNZ67a0.s:943    .text.startup:0000000000000000 main
     /tmp/ccNZ67a0.s:1068   .bss:0000000000000005 usi_i2c_requestedAddres
     /tmp/ccNZ67a0.s:1084   .data:0000000000000002 usi_i2c_byteToTransmit
     /tmp/ccNZ67a0.s:1240   .progmem.data:0000000000000000 header

UNDEFINED SYMBOLS
__udivmodqi4
set_heartBlink
hfm_setPower
hfm_nextOutput
sineRaw8
hfm_setup
init_heartBeat
setHeartRate
heartBlink
heartUpdate
__do_copy_data
__do_clear_bss
